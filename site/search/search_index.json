{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"01_introduction/","text":"Introduction Goal This project is a personal learning exercise in which my goal is to develop a parser for arithmetic expressions using the Functional Programming/Category Theoretic machinery of Functors, Applicatives, and Monads. Motivation I have been dabbling with functional programming in Haskell and Ocaml for sometime but have found it difficult to get my head around. This is particular gauling because as well as a programmer I am (or was) a Category Theorist, and in my Doctoral Dissertation I proved some Theorems about Monads (as least Monads in a 2-category that in those days were called Doctrines). So I am very familiar with the Category Theory, but have still found Haskell's interpretation of those concepts difficult to absorb. So this project is a concerted effort to learn or at least get over the hump. I have chosen to implement this project in Typescript. It is a language I know reasonably well, has an adequate type system (for most things but as we will see not for this project) and it is a traditional enough imperative language that any programmer should be able to follow along as I implement the various concepts. Notation Comparison I believe the notation used in Haskell, Ocaml and other ML related languages get in the way of the Category Theorist in me grasping what is going on. Here is a brief discussion of the differences. FP/Haskell operates in the Hask category where objects are types (as defined by the languages type rules) and arrows are functions between types. In CT (an abbreviation for the term Category Theory) objects are upper case whereas in Haskell they are lower eg A vs a . In CT the notation A -> B represents a particular arrow/function between two objects. However Haskell has no equivalent diagramatic notation for a single arrow. The Haskell notation a -> b is a type, specifically the type of all arrows from a to b , and is another object is the Hask category. The equivalent in CT is B A or sometimes [A, B] , or sometimes A => B and is an object in the Hask category . This is what makes Hask a closed category . See more below. So if M (or m in Haskell) is a functor in CT M(A->B) is the functor applied to an arrow f:A->B . In Haskell this would be fmap(f) . On the otehrhand the equivalent Haskell notation m(a-> b) is the functor applied to the object a->b . What a CT'ist would call M([A,B]) . This is difference in the meaning of m(a->b) has definitely caused me grief and substantially slowed my understanding. CT represents the set of all arrows from A to B by Hom(A, B) . There is no equivalent in Haskell other than to say that ab is a value of type (a -> b) . Finally consider pairs. If A/a and B/b are objects in (CT/Haskell) respectively the type of all pairs is called A x B or A \u2297 B in Category Theory, and (a, b) in Haskell. Together AxB and [A, B] make Hask a catersian/monoidal closed category, which is the equiavalent of currying . An exposition as well as a parser In addition to providing typescript code that implements an Applicative and/or Monadic parser I hope to explain and document for myself the various relationships between Applicatives and Monads and their various formulations. I apologize in advance because this additional goal will force me at times to dive into the category theory and to use more CT like notation. Hence the next heading is intended to provide a bit of a reference if things get confusing. Notation for this document Objects are uppercase. This is consistent with Typescript general usage. A -> B means a specific arrow from A to B . A => B is the type of arrows from A to B . Typescript will often insist that I write is (a:A)=>B . When a discussion is mainly Category Theoretic I might use [A, B] for A=>B . Functors, Applicatives, Monads are always represented by uppercase letters or a name starting with an uppercase letter, such as Maybe . Functor application will uses angle brackets F<A> (or a Haskell like convention of F A ) is the functor F applied to the object A . This is a Typescript requirement. We might occasionally slip and write F<A->B> when we mean fmap<A->B> . We will generally write A x B as the type of pairs of [A, B] except when Typescript insists on using the second notation. A function that takes n arguments is not the same as a function that takes a single n-tuple . Nor is it the same as the function resulting from full or partial currying . These are equivalent (meaning there is an isomorphism that maps one to the other and back again) but not the same. Typescript also insists on this differentiation. Two code solutions I started this project by building a parser for arithmetic expressions using what I thought of as a FP approach but without using any of the machinery of Functors, Applicatives, Monads. At least not explicitly. I have kept that solution for the purposes of illustration and comparison in the sub directory initial-solution . To run this solution on some test cases simply enter ts-node initial-solution/main.ts My final solution using the power of Functors, Applicatives and Monads is in the src sub directory. The tests directory runs a series of unit tests of the pieces and final solution. Anatomy of the solutions Both the code solutions have broadly the same structure. A parsing function takes in a character string and produces either some indication of failure or a data structure called an Abstract Syntax Tree an Ast . This function is in the file initial-soluton/parser.ts for the initial or naive solution and the file src/parser.ts for the Categorical solution. There are type definitions and constructor functions for the Ast in the files src/tree/tree.ts and src/tree/tree.ts and these are common to both solutions. The files stc/tree/walker.ts contains functions that traverse an Ast and either evaluation the arithmetic expression or construct a canonical string representation of the Ast .","title":"Introduction"},{"location":"01_introduction/#introduction","text":"","title":"Introduction"},{"location":"01_introduction/#goal","text":"This project is a personal learning exercise in which my goal is to develop a parser for arithmetic expressions using the Functional Programming/Category Theoretic machinery of Functors, Applicatives, and Monads.","title":"Goal"},{"location":"01_introduction/#motivation","text":"I have been dabbling with functional programming in Haskell and Ocaml for sometime but have found it difficult to get my head around. This is particular gauling because as well as a programmer I am (or was) a Category Theorist, and in my Doctoral Dissertation I proved some Theorems about Monads (as least Monads in a 2-category that in those days were called Doctrines). So I am very familiar with the Category Theory, but have still found Haskell's interpretation of those concepts difficult to absorb. So this project is a concerted effort to learn or at least get over the hump. I have chosen to implement this project in Typescript. It is a language I know reasonably well, has an adequate type system (for most things but as we will see not for this project) and it is a traditional enough imperative language that any programmer should be able to follow along as I implement the various concepts.","title":"Motivation"},{"location":"01_introduction/#notation-comparison","text":"I believe the notation used in Haskell, Ocaml and other ML related languages get in the way of the Category Theorist in me grasping what is going on. Here is a brief discussion of the differences. FP/Haskell operates in the Hask category where objects are types (as defined by the languages type rules) and arrows are functions between types. In CT (an abbreviation for the term Category Theory) objects are upper case whereas in Haskell they are lower eg A vs a . In CT the notation A -> B represents a particular arrow/function between two objects. However Haskell has no equivalent diagramatic notation for a single arrow. The Haskell notation a -> b is a type, specifically the type of all arrows from a to b , and is another object is the Hask category. The equivalent in CT is B A or sometimes [A, B] , or sometimes A => B and is an object in the Hask category . This is what makes Hask a closed category . See more below. So if M (or m in Haskell) is a functor in CT M(A->B) is the functor applied to an arrow f:A->B . In Haskell this would be fmap(f) . On the otehrhand the equivalent Haskell notation m(a-> b) is the functor applied to the object a->b . What a CT'ist would call M([A,B]) . This is difference in the meaning of m(a->b) has definitely caused me grief and substantially slowed my understanding. CT represents the set of all arrows from A to B by Hom(A, B) . There is no equivalent in Haskell other than to say that ab is a value of type (a -> b) . Finally consider pairs. If A/a and B/b are objects in (CT/Haskell) respectively the type of all pairs is called A x B or A \u2297 B in Category Theory, and (a, b) in Haskell. Together AxB and [A, B] make Hask a catersian/monoidal closed category, which is the equiavalent of currying .","title":"Notation Comparison"},{"location":"01_introduction/#an-exposition-as-well-as-a-parser","text":"In addition to providing typescript code that implements an Applicative and/or Monadic parser I hope to explain and document for myself the various relationships between Applicatives and Monads and their various formulations. I apologize in advance because this additional goal will force me at times to dive into the category theory and to use more CT like notation. Hence the next heading is intended to provide a bit of a reference if things get confusing.","title":"An exposition as well as a parser"},{"location":"01_introduction/#notation-for-this-document","text":"Objects are uppercase. This is consistent with Typescript general usage. A -> B means a specific arrow from A to B . A => B is the type of arrows from A to B . Typescript will often insist that I write is (a:A)=>B . When a discussion is mainly Category Theoretic I might use [A, B] for A=>B . Functors, Applicatives, Monads are always represented by uppercase letters or a name starting with an uppercase letter, such as Maybe . Functor application will uses angle brackets F<A> (or a Haskell like convention of F A ) is the functor F applied to the object A . This is a Typescript requirement. We might occasionally slip and write F<A->B> when we mean fmap<A->B> . We will generally write A x B as the type of pairs of [A, B] except when Typescript insists on using the second notation. A function that takes n arguments is not the same as a function that takes a single n-tuple . Nor is it the same as the function resulting from full or partial currying . These are equivalent (meaning there is an isomorphism that maps one to the other and back again) but not the same. Typescript also insists on this differentiation.","title":"Notation for this document"},{"location":"01_introduction/#two-code-solutions","text":"I started this project by building a parser for arithmetic expressions using what I thought of as a FP approach but without using any of the machinery of Functors, Applicatives, Monads. At least not explicitly. I have kept that solution for the purposes of illustration and comparison in the sub directory initial-solution . To run this solution on some test cases simply enter ts-node initial-solution/main.ts My final solution using the power of Functors, Applicatives and Monads is in the src sub directory. The tests directory runs a series of unit tests of the pieces and final solution.","title":"Two code solutions"},{"location":"01_introduction/#anatomy-of-the-solutions","text":"Both the code solutions have broadly the same structure. A parsing function takes in a character string and produces either some indication of failure or a data structure called an Abstract Syntax Tree an Ast . This function is in the file initial-soluton/parser.ts for the initial or naive solution and the file src/parser.ts for the Categorical solution. There are type definitions and constructor functions for the Ast in the files src/tree/tree.ts and src/tree/tree.ts and these are common to both solutions. The files stc/tree/walker.ts contains functions that traverse an Ast and either evaluation the arithmetic expression or construct a canonical string representation of the Ast .","title":"Anatomy of the solutions"},{"location":"02_maybe_monad/","text":"Maybe Monad The Haskell Maybe Monad is available in many languages under the name Optional , Nullable , or Union with null. In TS we can define a type that optionally has a value as Nullable<T> which is defined as T | null . However I chose to befine a type Maybe<T> more like the definition from Haskel. class Maybe<T> { private value: T | null private constructor(v: T|null) { this.value = v } public static just(t: T): Maybe<T> { return new Maybe<T>(t) } public static nothing(): Maybe<T> { return new Maybe<T>(null) } public static isNothing(r: Maybe<T>): bool { return (r.value === null) } public static getValue(r: Maybe<T>): T { if(r.value === null) { throw Error(\"trying to be value from a nothing Maybe\") } return r.value } } The benefit of this definition is that it more closely follows the Haskel notation, and hence is an aid to understanding.","title":"The Maybe Monad"},{"location":"02_maybe_monad/#maybe-monad","text":"The Haskell Maybe Monad is available in many languages under the name Optional , Nullable , or Union with null. In TS we can define a type that optionally has a value as Nullable<T> which is defined as T | null . However I chose to befine a type Maybe<T> more like the definition from Haskel. class Maybe<T> { private value: T | null private constructor(v: T|null) { this.value = v } public static just(t: T): Maybe<T> { return new Maybe<T>(t) } public static nothing(): Maybe<T> { return new Maybe<T>(null) } public static isNothing(r: Maybe<T>): bool { return (r.value === null) } public static getValue(r: Maybe<T>): T { if(r.value === null) { throw Error(\"trying to be value from a nothing Maybe\") } return r.value } } The benefit of this definition is that it more closely follows the Haskel notation, and hence is an aid to understanding.","title":"Maybe Monad"},{"location":"02_parsing_intro/","text":"Parsing Arithmetic Expressions Recall that the mission of this project is to build a programs that - parses arithmetic expressions into a data structure I will call an Ast , - evaluates such a data structure, - and prints such a data structure. Here is a BNF specification of arithmetic expressions: expression ::= term \"+\" expression | term term ::= factor \"*\" term | factor factor ::= number | \"(\" expression \")\" number ::= digit , number | digit digit ::= \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\" What is a parser ? If you read a Haskel text book there is a chance you will find this little rhyme: A parser for things is a functions from strings to lists of pairs of things and strings Putting this rhyme into a definition yields something like: type Parser<T> = (s: string) => Array<[T, string]> While this definition is simple I have decided, after much experimentation, that I dont like it for \"real\" programs. My reasons: returning an empty array to signal parsing failed seems like a poor approach for a Functional Programming exercise. Why not use type Optional<T> = T | Null or the Maybe Monad . See the section entitled Maybe Monad for details. I found no need for a parser to return multiple tuples in any of my experiments in this project. accessing the elements of a tupe using tup[0] and tup[1] seems error prone and difficult to change (many edit sites) Instead I decide to use the following (style) of definition. type PPairClass<T> = .... type Parser<T> = (s: string) => Maybe<PPairClass<T>> where PPairClass is a \"pair like\" immutable structure that satisfies the following interface. Immutable because the properties value and remaining_input are/should be read only. interface PPairClass<T> { static make<T>(v: T, remaining_input: string): PPairClass<T>; readonly value: T readonly remaining_input: string } To simplify the notation I will henceforth use type PP<T> = PPairClass<T> type Parser<T> = (sinput string) => Maybe<PP<T>>","title":"Parsing"},{"location":"02_parsing_intro/#parsing","text":"","title":"Parsing"},{"location":"02_parsing_intro/#arithmetic-expressions","text":"Recall that the mission of this project is to build a programs that - parses arithmetic expressions into a data structure I will call an Ast , - evaluates such a data structure, - and prints such a data structure. Here is a BNF specification of arithmetic expressions: expression ::= term \"+\" expression | term term ::= factor \"*\" term | factor factor ::= number | \"(\" expression \")\" number ::= digit , number | digit digit ::= \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\"","title":"Arithmetic Expressions"},{"location":"02_parsing_intro/#what-is-a-parser","text":"If you read a Haskel text book there is a chance you will find this little rhyme: A parser for things is a functions from strings to lists of pairs of things and strings Putting this rhyme into a definition yields something like: type Parser<T> = (s: string) => Array<[T, string]> While this definition is simple I have decided, after much experimentation, that I dont like it for \"real\" programs. My reasons: returning an empty array to signal parsing failed seems like a poor approach for a Functional Programming exercise. Why not use type Optional<T> = T | Null or the Maybe Monad . See the section entitled Maybe Monad for details. I found no need for a parser to return multiple tuples in any of my experiments in this project. accessing the elements of a tupe using tup[0] and tup[1] seems error prone and difficult to change (many edit sites) Instead I decide to use the following (style) of definition. type PPairClass<T> = .... type Parser<T> = (s: string) => Maybe<PPairClass<T>> where PPairClass is a \"pair like\" immutable structure that satisfies the following interface. Immutable because the properties value and remaining_input are/should be read only. interface PPairClass<T> { static make<T>(v: T, remaining_input: string): PPairClass<T>; readonly value: T readonly remaining_input: string } To simplify the notation I will henceforth use type PP<T> = PPairClass<T> type Parser<T> = (sinput string) => Maybe<PP<T>>","title":"What is a parser ?"},{"location":"03_building_parsers/","text":"Combining Parsers It will turn out that our goal of building a parser for arithmetic expressions will be achieved by combining simpler or more elementary parsers in a number of ways. Single Character Parsers The simplest parser of all is one that successfully parser any single character. Thus our first example of a parser below is one that parses any single character whether or not preceeded by whitespace. /** * Match any single non-whitespace character */ function parseAnyChar<string>(sinput: string): Maybe<PPairClass<string>> { const s = removewhitespace(sinput) if(sinput.length ==0) return Maybe.nothing() const value = s.substring(0,1) const remainder = s.slice(1) return Maybe.just(PPairClass.make(value, remainder)) } This can trivially be modified to provide a parse that can successfully parse any single digit. Note we have not consumed leading whitespace. /** * Parse a digit without consuming leading white space */ function parseSingleDigit(sinput string): Maybe<PPairClass<string>> { const s = sinput.slice(0) if((s.length == 0) || (s.substring(0, 1).match(/[0-9]/g) == null) { return Maybe.nothing() } const value = s.substring(0,1) const remainder = s.slice(1) return Maybe.just(PPairClass.make(value, remainder)) } It will turnout that a parser that can parse any single character that satisfies a boolean predicate is a very useful tool. /** * Return a parser that parses the next single character in the input if it satisfies * a predicate */ function createPredicateParser(predicate (ch: string) => boolean): Parser<string> { return (s: string) => { if((sinput.length == 0) || (! predicate(s.substring(0,1)))) return Maybe.nothing() const value = s.substring(0,1) const remainder = s.slice(1) return Maybe.just(PPairClass.make(value, remaiinder)) } } As the final example of this section we will make a parser that successfully parser a single whitespace character; const oneWhitespaceCharacterParser = createPredicateParser((ss) => ss.substring(0,1).match(/[\\s]/g) ) The One-or-more parser Its clear that in order to parser arithmentic expression we will need to be able to parse numbers which are a sequence of one or more digits. Above we have a parser that can parse single digits. How to we use that to parse a sequence of one or more digits. This is what I think of as the one-or-more parser. /* * Take a parser for a single character meeting some criteria and return * a parser that detects greater than zero consecutive instances of such characters */ function create_OneOrMoreParser(singleChParser: Parser<string>): Parser<string> { function functionManyTimes(sinput: string) => { let s = sinput.slice(0) const r = singleChParser(s) let parse_result = \"\" if(Maybe.isNothing(r)) { return Maybe.nothing() } const pair = Maybe.get_value(r) const first_ok_char_as_str = pair.value const remain = pair.remaining_input const r2 = manyTimes(remain) if(Maybe.isNothing(r2)) { return Maybe.nothing() } const result_pair = Maybe.get_value(r2) const subsequent_ok_chars_as_string = result_pair.value const parse_result_string = first_digit_as_string + subsequent_digits_as_string return Maybe.just(PPairClass.make(parse_result, pair2.remaining_input)) } return functionManyTimes } The experienced Haskel programmer will observe that the create_OneOrMoreParser() could have used more of the Monad properties of the Maybe Monad . We will come back to that eventually. The one-or-more constructor makes parsing numbers easy. As below. function parseNumber(sinput: string): Maybe<PPairClass<number>> { const digitParser = createPredicateParser((ss: string) => (ss.substring(0, 1).match(/[0-9]/g))) const numParser = create_OneOrMoreParser(digitParser) return numParser(s) } As a second example of the use of the create_OneOrMoreParser() lets make a parser that can successfully parse uppercase words (sequences of upper case letters). function parseUppercaseWords(sinput: string): Maybe<PPairClass<number>> { const upperCaseLetterParser = createPredicateParser((ss: string) => (ss.substring(0, 1).match(/[A-Z]/g))) const upperCaseWordParser = create_OneOrMoreParser(upperCaseLetterParser) return upperCaseWordParser(s) } Whitespace The following strings 2 + 3* (4 + 1) and 2+3*(4+1) are equivalent as arithmetic expressions because whitespace between the terms does not change the interpretation of the expression. Thus we have a decision to make. When we parse expressions do we keep track of the white space so that the exact input string can be recreated froom the Ast (such as string 1 above), do we use eliminate whitespace during the parsing process like in string 2 above, or maybe reduce each sequence of whitespace to a single space character like 2 + 3 * ( 4 + 1 ) . We will chose to eliminate whitespace. Before continuing lets make a function that parses a sequence of whitespace. const whitespaceParser = create_OneOrMoreParser(oneWhitespaceCharParser) Hence many of the parser function we design will be required to eliminate all whitespace from the front of their input string before attempting to parse an input string. Consider a parser const p: (sinput: string) => Maybe<PP<T>> . Here is a function that converts that parser p to a new parser that strips whitespace from the front of the input string. function whitespaceIfy(p (sinput: string) => Maybe<PP<T>>) (sinput: string) => Maybe<PP<T>> { return function(sinput: string): Maybe<PP<T>> { const r = whitespaceParser(sinput) const sin = (Maybe.isNothing(r)) ? sinput: Maybe.get_remainder(r) return p(sin) } } Alternatives or - the OR parser Consider that task of parsing strings which are either numbers, a sequence of digits capitalized words, a sequence of uppercase letters This can be achieved by: first applying parseNumber() and if successfull its return value is the return value of our desired parser. if parseNumber() fails then apply parseUppercaseWords() and use its return value. In code this looks like: function parseNumberOrUppercaseWord(sinput string): Maybe<PPairClass<string|number>> { const r1 = parserNumber(sinput) if(Maybe.isNothing(r1)) { const r2 = parseUppercaseWord(sinput) if(Maybe.isNothing(r2)) return Maybe.nothing<string|number>() const numb = r2.get_value() return Maybe.just<string|number>(numb)) } const s string = r1.get_value() return Maybe.just<string|number>(s) } Infact this is a general construct. Given two parsers: const p1: (s string) => Maybe<PPairClass<T>> const p2: (s string) => Maybe<PPairClass<R>> We can get a p1_OR_p2 parser as follows: function OR_parser(p1 (s string) => Maybe<PPairClass<T>>, p2 (s string) => Maybe<PPairClass<R>>): (s string) => Maybe<PPairClass<T|R>> { return function(sinput string): Maybe<PPairCase<T|R>> { const r1 = parserNumber(sinput) if(Maybe.isNothing(r1)) { const r2 = parseUppercaseWord(sinput) if(Maybe.isNothing(r2)) return Maybe.nothing<T|R>() const v2 R = r2.get_value() return Maybe.just<T|R>(v2)) } const tvalue T = r1.get_value() return Maybe.just<T|R>(s) } } Followed By Parser Lets make a function that will parser variable names. Variable names: must start with an upper or lower case letter or an underscore _ thereafter there may be zero of more characters that are either digits, uppercase letters, lowercase letters or underscores. Its pretty clear that we can do this by first parsing the initial character with const firstCharParser = createPredicateParser((s) => (s.substring(0, 1).match(/[a-zA-Z_]/g)) ) and then parsing all of the remaining characters with: const subsequentCharParser = create_OneOrMoreParser(createPredicateParser((s) => (s.substring(0, 1).match(/[a-zA-Z_]/g)))) So now lets turn our attention to creating a function that combines firstCharParser and sunsequentCharParser as described above. function variableNameParser(sinput: string): Maybe<PP<string>> { const r1 = firstCharParser(sinput) if(Maybe.isNothing(r1)) { return r1 } return subsequentCharParser(Maybe.get_value(r1)) }","title":"Combining Parsers"},{"location":"03_building_parsers/#combining-parsers","text":"It will turn out that our goal of building a parser for arithmetic expressions will be achieved by combining simpler or more elementary parsers in a number of ways.","title":"Combining Parsers"},{"location":"03_building_parsers/#single-character-parsers","text":"The simplest parser of all is one that successfully parser any single character. Thus our first example of a parser below is one that parses any single character whether or not preceeded by whitespace. /** * Match any single non-whitespace character */ function parseAnyChar<string>(sinput: string): Maybe<PPairClass<string>> { const s = removewhitespace(sinput) if(sinput.length ==0) return Maybe.nothing() const value = s.substring(0,1) const remainder = s.slice(1) return Maybe.just(PPairClass.make(value, remainder)) } This can trivially be modified to provide a parse that can successfully parse any single digit. Note we have not consumed leading whitespace. /** * Parse a digit without consuming leading white space */ function parseSingleDigit(sinput string): Maybe<PPairClass<string>> { const s = sinput.slice(0) if((s.length == 0) || (s.substring(0, 1).match(/[0-9]/g) == null) { return Maybe.nothing() } const value = s.substring(0,1) const remainder = s.slice(1) return Maybe.just(PPairClass.make(value, remainder)) } It will turnout that a parser that can parse any single character that satisfies a boolean predicate is a very useful tool. /** * Return a parser that parses the next single character in the input if it satisfies * a predicate */ function createPredicateParser(predicate (ch: string) => boolean): Parser<string> { return (s: string) => { if((sinput.length == 0) || (! predicate(s.substring(0,1)))) return Maybe.nothing() const value = s.substring(0,1) const remainder = s.slice(1) return Maybe.just(PPairClass.make(value, remaiinder)) } } As the final example of this section we will make a parser that successfully parser a single whitespace character; const oneWhitespaceCharacterParser = createPredicateParser((ss) => ss.substring(0,1).match(/[\\s]/g) )","title":"Single Character Parsers"},{"location":"03_building_parsers/#the-one-or-more-parser","text":"Its clear that in order to parser arithmentic expression we will need to be able to parse numbers which are a sequence of one or more digits. Above we have a parser that can parse single digits. How to we use that to parse a sequence of one or more digits. This is what I think of as the one-or-more parser. /* * Take a parser for a single character meeting some criteria and return * a parser that detects greater than zero consecutive instances of such characters */ function create_OneOrMoreParser(singleChParser: Parser<string>): Parser<string> { function functionManyTimes(sinput: string) => { let s = sinput.slice(0) const r = singleChParser(s) let parse_result = \"\" if(Maybe.isNothing(r)) { return Maybe.nothing() } const pair = Maybe.get_value(r) const first_ok_char_as_str = pair.value const remain = pair.remaining_input const r2 = manyTimes(remain) if(Maybe.isNothing(r2)) { return Maybe.nothing() } const result_pair = Maybe.get_value(r2) const subsequent_ok_chars_as_string = result_pair.value const parse_result_string = first_digit_as_string + subsequent_digits_as_string return Maybe.just(PPairClass.make(parse_result, pair2.remaining_input)) } return functionManyTimes } The experienced Haskel programmer will observe that the create_OneOrMoreParser() could have used more of the Monad properties of the Maybe Monad . We will come back to that eventually. The one-or-more constructor makes parsing numbers easy. As below. function parseNumber(sinput: string): Maybe<PPairClass<number>> { const digitParser = createPredicateParser((ss: string) => (ss.substring(0, 1).match(/[0-9]/g))) const numParser = create_OneOrMoreParser(digitParser) return numParser(s) } As a second example of the use of the create_OneOrMoreParser() lets make a parser that can successfully parse uppercase words (sequences of upper case letters). function parseUppercaseWords(sinput: string): Maybe<PPairClass<number>> { const upperCaseLetterParser = createPredicateParser((ss: string) => (ss.substring(0, 1).match(/[A-Z]/g))) const upperCaseWordParser = create_OneOrMoreParser(upperCaseLetterParser) return upperCaseWordParser(s) }","title":"The One-or-more parser"},{"location":"03_building_parsers/#whitespace","text":"The following strings 2 + 3* (4 + 1) and 2+3*(4+1) are equivalent as arithmetic expressions because whitespace between the terms does not change the interpretation of the expression. Thus we have a decision to make. When we parse expressions do we keep track of the white space so that the exact input string can be recreated froom the Ast (such as string 1 above), do we use eliminate whitespace during the parsing process like in string 2 above, or maybe reduce each sequence of whitespace to a single space character like 2 + 3 * ( 4 + 1 ) . We will chose to eliminate whitespace. Before continuing lets make a function that parses a sequence of whitespace. const whitespaceParser = create_OneOrMoreParser(oneWhitespaceCharParser) Hence many of the parser function we design will be required to eliminate all whitespace from the front of their input string before attempting to parse an input string. Consider a parser const p: (sinput: string) => Maybe<PP<T>> . Here is a function that converts that parser p to a new parser that strips whitespace from the front of the input string. function whitespaceIfy(p (sinput: string) => Maybe<PP<T>>) (sinput: string) => Maybe<PP<T>> { return function(sinput: string): Maybe<PP<T>> { const r = whitespaceParser(sinput) const sin = (Maybe.isNothing(r)) ? sinput: Maybe.get_remainder(r) return p(sin) } }","title":"Whitespace"},{"location":"03_building_parsers/#alternatives-or-the-or-parser","text":"Consider that task of parsing strings which are either numbers, a sequence of digits capitalized words, a sequence of uppercase letters This can be achieved by: first applying parseNumber() and if successfull its return value is the return value of our desired parser. if parseNumber() fails then apply parseUppercaseWords() and use its return value. In code this looks like: function parseNumberOrUppercaseWord(sinput string): Maybe<PPairClass<string|number>> { const r1 = parserNumber(sinput) if(Maybe.isNothing(r1)) { const r2 = parseUppercaseWord(sinput) if(Maybe.isNothing(r2)) return Maybe.nothing<string|number>() const numb = r2.get_value() return Maybe.just<string|number>(numb)) } const s string = r1.get_value() return Maybe.just<string|number>(s) } Infact this is a general construct. Given two parsers: const p1: (s string) => Maybe<PPairClass<T>> const p2: (s string) => Maybe<PPairClass<R>> We can get a p1_OR_p2 parser as follows: function OR_parser(p1 (s string) => Maybe<PPairClass<T>>, p2 (s string) => Maybe<PPairClass<R>>): (s string) => Maybe<PPairClass<T|R>> { return function(sinput string): Maybe<PPairCase<T|R>> { const r1 = parserNumber(sinput) if(Maybe.isNothing(r1)) { const r2 = parseUppercaseWord(sinput) if(Maybe.isNothing(r2)) return Maybe.nothing<T|R>() const v2 R = r2.get_value() return Maybe.just<T|R>(v2)) } const tvalue T = r1.get_value() return Maybe.just<T|R>(s) } }","title":"Alternatives or - the OR parser"},{"location":"03_building_parsers/#followed-by-parser","text":"Lets make a function that will parser variable names. Variable names: must start with an upper or lower case letter or an underscore _ thereafter there may be zero of more characters that are either digits, uppercase letters, lowercase letters or underscores. Its pretty clear that we can do this by first parsing the initial character with const firstCharParser = createPredicateParser((s) => (s.substring(0, 1).match(/[a-zA-Z_]/g)) ) and then parsing all of the remaining characters with: const subsequentCharParser = create_OneOrMoreParser(createPredicateParser((s) => (s.substring(0, 1).match(/[a-zA-Z_]/g)))) So now lets turn our attention to creating a function that combines firstCharParser and sunsequentCharParser as described above. function variableNameParser(sinput: string): Maybe<PP<string>> { const r1 = firstCharParser(sinput) if(Maybe.isNothing(r1)) { return r1 } return subsequentCharParser(Maybe.get_value(r1)) }","title":"Followed By Parser"},{"location":"04_ast/","text":"Abstract Syntax Tree Most of the parser we deal with will (on success) produce part of a structure called an Abstract Syntax Tree . This will be a binary tree that represents the portion of the expression that has just been parsed. Ideally we would define the tree in a manner that parallels the BNF definition of an expression. In Haskell Something like: data TreeNode a = PlusNode TreeNode TreeNode | MultNode TreeNode TreeNode | BracketNode TreeNode | NumberNode string However this or something like it is not possible in Typescript. After a good deal of experimentation I came to the following Typescript immitation: abstract class TreeNode {....} class PlusNode extends TreeNode {left: TreeNode; right: TreeNode} class MultNode extends TreeNode {left: TreeNode; right: TreeNode} class BracketNode extends TreeNode {inside: TreeNode} class NumberNode extends TreeNode {value: number} Each concrete class has a static method make that creates an instance of the class with the appropriate arguments, as follows: PlusNode.make(left: TreeNode, right: TreeNode) MultNode.make(left: TreeNode, right: TreeNode) BracketNode.make(child: TreeNode) NumberNode.make(n: number) each of these make functions return a frozen object to ensure immutability. When manipulating TreeNodes one often needs to know the concrete type of a TreeNode . To facilitate this there are a set of free functions with names like isMultNode(node: TreeNode): boolean which can be used in an if-ifelse-else chain. Once having determined the concrete type of a TreeNode such a node needs to be \"cast\" to the appropriate concrete type. There are a suite of functions to do this, with error checking. Names like asMultNode(node: TreeNode): MultNode . The above arrangement provides an equivalent to the Haskell data statement provided earlier. However because of the type casting type safety depends on hand coded runtime checking. Unfortunately this is as close as I can get in Typescript to Haskells pattern matching. Convenience Node Types Todo Some Simple Parsers Consider the following simple parser: /** * Match any single character */ function parseAnyChar<string>(sinput: string): Maybe<PPairClass<string>> { const s = removewhitespace(sinput) if(sinput.length ==0) return Maybe.nothing() const value = s.substring(0,1) const remainder = s.slice(1) return Maybe.just(PPairClass.make(value, remainder)) } /** * Parse a digit without consuming leading white space */ function parseSingleDigit(sinput string): Maybe<PPairClass<string>> { const s = sinput.slice(0) if((s.length == 0) || (s.substring(0, 1).match(/[0-9]/g) == null) { return Maybe.nothing() } const value = s.substring(0,1) const remainder = s.slice(1) return Maybe.just(PPairClass.make(value, remainder)) } /** * Return a parser that parses the next single character in the input if it satisfies * a predicate */ function createPredicateParser(predicate (ch: string) => boolean): Parser<string> { return (s: string) => { if((sinput.length == 0) || (! predicate(s.substring(0,1)))) return Maybe.nothing() const value = s.substring(0,1) const remainder = s.slice(1) return Maybe.just(PPairClass.make(value, remaiinder)) } } /* * Take a parser for a single character meeting some criteria and return * a parser that detects greater than zero consecutive instances of such characters */ function create_OneOrMoreParser(singleChParser: Parser<string>): Parser<string> { function functionManyTimes(sinput: string) => { let s = sinput.slice(0) const r = singleChParser(s) let parse_result = \"\" if(Maybe.isNothing(r)) { return Maybe.nothing() } const pair = Maybe.get_value(r) const first_ok_char_as_str = pair.value const remain = pair.remaining_input const r2 = manyTimes(remain) if(Maybe.isNothing(r2)) { return Maybe.nothing() } const result_pair = Maybe.get_value(r2) const subsequent_ok_chars_as_string = result_pair.value const parse_result_string = first_digit_as_string + subsequent_digits_as_string return Maybe.just(PPairClass.make(parse_result, pair2.remaining_input)) } return functionManyTimes } function parseNumber(sinput string): Maybe<PPairClass<number>> { const digitParser = createPredicateParser((ss: string) => (ss.substring(0, 1).match(/[0-9]/g))) const numParser = create_OneOrMoreParser(digitParser) const removewhitespace = (sinput: string) => { const s = sinput.slice(sinput) const r = create_OneOrMoreParser(createPredicateParser((ss) => ss.substring(0,1).match(/[ ]/g) ))(s) if(Maybe.isNothing()) let s = removewhitespace(sinput) return numParser(s) // const r = digit(s) // let num = \"\" // if(Maybe.isNothing(r)) { // return Maybe.nothing() // } // const pair = Maybe.get_value(r) // num = pair.value // const remain = pair.remaining_input // const r2 = number(remain) // if(!Maybe.isNothing(r2)) { // const pair2 = Maybe.get_value(r2) // num = num + pair2.value // const numberValue = parseInt(num) // if(isNaN(numberValue)) // throw new Error(`something went wrong` ) // Maybe.just(PPairClass.make(num, pair2.remaining_input)) }","title":"Ast"},{"location":"04_ast/#abstract-syntax-tree","text":"Most of the parser we deal with will (on success) produce part of a structure called an Abstract Syntax Tree . This will be a binary tree that represents the portion of the expression that has just been parsed. Ideally we would define the tree in a manner that parallels the BNF definition of an expression. In Haskell Something like: data TreeNode a = PlusNode TreeNode TreeNode | MultNode TreeNode TreeNode | BracketNode TreeNode | NumberNode string However this or something like it is not possible in Typescript. After a good deal of experimentation I came to the following Typescript immitation: abstract class TreeNode {....} class PlusNode extends TreeNode {left: TreeNode; right: TreeNode} class MultNode extends TreeNode {left: TreeNode; right: TreeNode} class BracketNode extends TreeNode {inside: TreeNode} class NumberNode extends TreeNode {value: number} Each concrete class has a static method make that creates an instance of the class with the appropriate arguments, as follows: PlusNode.make(left: TreeNode, right: TreeNode) MultNode.make(left: TreeNode, right: TreeNode) BracketNode.make(child: TreeNode) NumberNode.make(n: number) each of these make functions return a frozen object to ensure immutability. When manipulating TreeNodes one often needs to know the concrete type of a TreeNode . To facilitate this there are a set of free functions with names like isMultNode(node: TreeNode): boolean which can be used in an if-ifelse-else chain. Once having determined the concrete type of a TreeNode such a node needs to be \"cast\" to the appropriate concrete type. There are a suite of functions to do this, with error checking. Names like asMultNode(node: TreeNode): MultNode . The above arrangement provides an equivalent to the Haskell data statement provided earlier. However because of the type casting type safety depends on hand coded runtime checking. Unfortunately this is as close as I can get in Typescript to Haskells pattern matching.","title":"Abstract Syntax Tree"},{"location":"04_ast/#convenience-node-types","text":"Todo","title":"Convenience Node Types"},{"location":"04_ast/#some-simple-parsers","text":"Consider the following simple parser: /** * Match any single character */ function parseAnyChar<string>(sinput: string): Maybe<PPairClass<string>> { const s = removewhitespace(sinput) if(sinput.length ==0) return Maybe.nothing() const value = s.substring(0,1) const remainder = s.slice(1) return Maybe.just(PPairClass.make(value, remainder)) } /** * Parse a digit without consuming leading white space */ function parseSingleDigit(sinput string): Maybe<PPairClass<string>> { const s = sinput.slice(0) if((s.length == 0) || (s.substring(0, 1).match(/[0-9]/g) == null) { return Maybe.nothing() } const value = s.substring(0,1) const remainder = s.slice(1) return Maybe.just(PPairClass.make(value, remainder)) } /** * Return a parser that parses the next single character in the input if it satisfies * a predicate */ function createPredicateParser(predicate (ch: string) => boolean): Parser<string> { return (s: string) => { if((sinput.length == 0) || (! predicate(s.substring(0,1)))) return Maybe.nothing() const value = s.substring(0,1) const remainder = s.slice(1) return Maybe.just(PPairClass.make(value, remaiinder)) } } /* * Take a parser for a single character meeting some criteria and return * a parser that detects greater than zero consecutive instances of such characters */ function create_OneOrMoreParser(singleChParser: Parser<string>): Parser<string> { function functionManyTimes(sinput: string) => { let s = sinput.slice(0) const r = singleChParser(s) let parse_result = \"\" if(Maybe.isNothing(r)) { return Maybe.nothing() } const pair = Maybe.get_value(r) const first_ok_char_as_str = pair.value const remain = pair.remaining_input const r2 = manyTimes(remain) if(Maybe.isNothing(r2)) { return Maybe.nothing() } const result_pair = Maybe.get_value(r2) const subsequent_ok_chars_as_string = result_pair.value const parse_result_string = first_digit_as_string + subsequent_digits_as_string return Maybe.just(PPairClass.make(parse_result, pair2.remaining_input)) } return functionManyTimes } function parseNumber(sinput string): Maybe<PPairClass<number>> { const digitParser = createPredicateParser((ss: string) => (ss.substring(0, 1).match(/[0-9]/g))) const numParser = create_OneOrMoreParser(digitParser) const removewhitespace = (sinput: string) => { const s = sinput.slice(sinput) const r = create_OneOrMoreParser(createPredicateParser((ss) => ss.substring(0,1).match(/[ ]/g) ))(s) if(Maybe.isNothing()) let s = removewhitespace(sinput) return numParser(s) // const r = digit(s) // let num = \"\" // if(Maybe.isNothing(r)) { // return Maybe.nothing() // } // const pair = Maybe.get_value(r) // num = pair.value // const remain = pair.remaining_input // const r2 = number(remain) // if(!Maybe.isNothing(r2)) { // const pair2 = Maybe.get_value(r2) // num = num + pair2.value // const numberValue = parseInt(num) // if(isNaN(numberValue)) // throw new Error(`something went wrong` ) // Maybe.just(PPairClass.make(num, pair2.remaining_input)) }","title":"Some Simple Parsers"},{"location":"applicative/","text":"\u2145 &CC; \ud835\udd39 \u212c \u0393 A\u2297Y","title":"Applicative"},{"location":"do_notation/","text":"1.0 do notation - what problem does it solve What problem does the Haskell do solve. Consider you have two functions f :: X -> M A and g :: Y -> M B which do some calculation that prepares input for a final \"bring it all together\" calculation represented by a function k :: (A, B) -> M C . As you can see all of these functions produce a Monadic result, maybe each calculation required some IO and M A may have failed so M A may equal IO Maybe A . But for the moment lets assume that M = Maybe (no IO). How would we apply k to the outcomes of f and g . In a typical imperative language we would write something like this: function combine(ma: M A, mb: M B, k: (A, B) -> M C): M C { if(ma.isNothing() || mb.isNothing()) { return Maybe.nothing() } const a = ma.get_value() const b = mb.get_value() return k(a, b) } The problem with the above solution is that it is Maybe specific. Is there a way of doing this for a general Monad ? The Haskell solution is combine :: (m a, m b, (a,b) -> m c) -> m c combine ma mb k = ma >>= (\\x -> mb >>= (\\y -> f x y)) or using do notation combine :: (m a, m b, (a,b) -> m c) -> m c combine ma mb k = do { x <- ma; y <- mb; k a b } For those like me that find the haskell hard to read the typescript version is function combine(ma: M<A>, mb: M<B>, k: (A, B) -> M<C>): M<C> { M.bind(ma, (a) => M.bind(mb, (b) => k(a,b))) } The nested function definitions (a) => M.bind(mb, (b) => k(a,b)) use scope to make the a and b available to the inner call to k(a, b) . Inline function definitions seem central to this construct. This is tested and demonstrated in file tests/test_do.ts . It should be noted that the above result can be rephrased as follows: Proposition 1: A function k: (A, B) -> M C can be extended to a function kprime: (M A, M B) -> M C . Proof: The calculation above is the proof. A more \"categorical\" approach So the above calculations seem to work but for me they are a computer scientists solution not a category theorists solution. Is there a \"higher level\" way of achieving the same end that operates at the level of \"arrows\" rather than nitty-gritty calculations. The answer of course is YES . In fact a little more is possible. Proposition 2: If M is a monad and p: A x B -> M C is a function then p can be extended to a function M A x M B -> M C An alternate proof: The following is a sequence of deductions/constructions. Each entry is derived from the preceeding entry with the justification being given in the second column. Id Function Reason the function can be deduced from the previous function 1. p: A x B -> M C The given or starting function 2. A -> [B, M C] The closed category isomorphism or currying of p 3. A -> [M B, M C] By applying the Kliesli or Monad extension theorem on the right side 4. A x M B -> M C The closed category isomorphism or reverse currying 5. M B x A -> M C Commutativity (up to isomorphism) of cartesian product 6. M B -> [A, M C] By currying 7. M B -> [M A, M C] By apply the Kliesli or Monad extension theorem 8. M B x M A -> M C By un currying 9. M A x M B -> M C commutativity (up to isomorphism) of cartesian product Now lets take some of these functions and deduce the formular for them. Equation 2. A -> [B, M C] is defined by \\a -> (\\b -> p(a, b)) Equation 3 A -> [M B, M C] is defined by \\a -> Kliesli(\\b -> p(a, b)) . Observe that Kliesli(\\b -> p(a, b)) is a function M B -> M C Equation 4. A x M B -> M C is defined by \\(a, mb) -> Kliesli(\\b -> p(a, b))(mb) or equivalently \\(a, mb) -> mb >>= (\\b -> p(a, b)) Equation 6. M B -> [A, M C] is defined by \\mb -> \\a -> Kliesli(\\b -> p(a, b))(mb) or equivalently \\mb -> (\\a -> mb >>= (\\b -> p(a, b)) ) Equation 7. M B -> [M A, M C] is defined by \\mb -> Kliesli(\\a -> Kliesli(\\b -> p(a, b))(mb) ) observe that Kliesli(\\a -> Kliesli(\\b -> p(a, b))(mb) ) is a function M A -> M C Equation 8. M B x M A -> M C is defined by \\(mb, ma) -> Kliesli(\\a -> Kliesli(\\b -> p(a, b))(mb) )(ma) or equivalently \\(mb, ma) -> ma >>= (\\a -> mb >>= (\\b -> p(a, b))) Finally by reordering the argument (mb, ma) to (ma, mb) we get: Equation 9. MA x M B -> M C defined as \\(ma, mb) -> Kliesli(\\a -> Kliesli(\\b -> p(a, b))(mb) )(ma) or equivalently \\(ma, mb) -> ma >>= (\\a -> mb >>= (\\b -> p(a, b))) Definition 1 We call the function defined in Equation 9 above Kliesli(p) In light of the above result we can now state that a Functor equipped with a Monadic structure is necessarily equipped with an Applicative structure. Proposition 3: If p: A x B -> C is a function and M is a monad then p can be lifted to a function liftA2(p) :M A x M B -> M C making M an Applicative Functor Proof: Consider the composition eta . p : A x B ---> C ---> M C . Now apply Kliesli to get Kliesli(eta . p): M A x M B -> M C . liftA2(p) = KLiesli(eta . p)","title":"Do notation"},{"location":"do_notation/#10-do-notation-what-problem-does-it-solve","text":"What problem does the Haskell do solve. Consider you have two functions f :: X -> M A and g :: Y -> M B which do some calculation that prepares input for a final \"bring it all together\" calculation represented by a function k :: (A, B) -> M C . As you can see all of these functions produce a Monadic result, maybe each calculation required some IO and M A may have failed so M A may equal IO Maybe A . But for the moment lets assume that M = Maybe (no IO). How would we apply k to the outcomes of f and g . In a typical imperative language we would write something like this: function combine(ma: M A, mb: M B, k: (A, B) -> M C): M C { if(ma.isNothing() || mb.isNothing()) { return Maybe.nothing() } const a = ma.get_value() const b = mb.get_value() return k(a, b) } The problem with the above solution is that it is Maybe specific. Is there a way of doing this for a general Monad ? The Haskell solution is combine :: (m a, m b, (a,b) -> m c) -> m c combine ma mb k = ma >>= (\\x -> mb >>= (\\y -> f x y)) or using do notation combine :: (m a, m b, (a,b) -> m c) -> m c combine ma mb k = do { x <- ma; y <- mb; k a b } For those like me that find the haskell hard to read the typescript version is function combine(ma: M<A>, mb: M<B>, k: (A, B) -> M<C>): M<C> { M.bind(ma, (a) => M.bind(mb, (b) => k(a,b))) } The nested function definitions (a) => M.bind(mb, (b) => k(a,b)) use scope to make the a and b available to the inner call to k(a, b) . Inline function definitions seem central to this construct. This is tested and demonstrated in file tests/test_do.ts . It should be noted that the above result can be rephrased as follows:","title":"1.0 do notation - what problem does it solve"},{"location":"do_notation/#proposition-1","text":"A function k: (A, B) -> M C can be extended to a function kprime: (M A, M B) -> M C . Proof: The calculation above is the proof.","title":"Proposition 1:"},{"location":"do_notation/#a-more-categorical-approach","text":"So the above calculations seem to work but for me they are a computer scientists solution not a category theorists solution. Is there a \"higher level\" way of achieving the same end that operates at the level of \"arrows\" rather than nitty-gritty calculations. The answer of course is YES . In fact a little more is possible.","title":"A more \"categorical\" approach"},{"location":"do_notation/#proposition-2","text":"If M is a monad and p: A x B -> M C is a function then p can be extended to a function M A x M B -> M C An alternate proof: The following is a sequence of deductions/constructions. Each entry is derived from the preceeding entry with the justification being given in the second column. Id Function Reason the function can be deduced from the previous function 1. p: A x B -> M C The given or starting function 2. A -> [B, M C] The closed category isomorphism or currying of p 3. A -> [M B, M C] By applying the Kliesli or Monad extension theorem on the right side 4. A x M B -> M C The closed category isomorphism or reverse currying 5. M B x A -> M C Commutativity (up to isomorphism) of cartesian product 6. M B -> [A, M C] By currying 7. M B -> [M A, M C] By apply the Kliesli or Monad extension theorem 8. M B x M A -> M C By un currying 9. M A x M B -> M C commutativity (up to isomorphism) of cartesian product Now lets take some of these functions and deduce the formular for them. Equation 2. A -> [B, M C] is defined by \\a -> (\\b -> p(a, b)) Equation 3 A -> [M B, M C] is defined by \\a -> Kliesli(\\b -> p(a, b)) . Observe that Kliesli(\\b -> p(a, b)) is a function M B -> M C Equation 4. A x M B -> M C is defined by \\(a, mb) -> Kliesli(\\b -> p(a, b))(mb) or equivalently \\(a, mb) -> mb >>= (\\b -> p(a, b)) Equation 6. M B -> [A, M C] is defined by \\mb -> \\a -> Kliesli(\\b -> p(a, b))(mb) or equivalently \\mb -> (\\a -> mb >>= (\\b -> p(a, b)) ) Equation 7. M B -> [M A, M C] is defined by \\mb -> Kliesli(\\a -> Kliesli(\\b -> p(a, b))(mb) ) observe that Kliesli(\\a -> Kliesli(\\b -> p(a, b))(mb) ) is a function M A -> M C Equation 8. M B x M A -> M C is defined by \\(mb, ma) -> Kliesli(\\a -> Kliesli(\\b -> p(a, b))(mb) )(ma) or equivalently \\(mb, ma) -> ma >>= (\\a -> mb >>= (\\b -> p(a, b))) Finally by reordering the argument (mb, ma) to (ma, mb) we get: Equation 9. MA x M B -> M C defined as \\(ma, mb) -> Kliesli(\\a -> Kliesli(\\b -> p(a, b))(mb) )(ma) or equivalently \\(ma, mb) -> ma >>= (\\a -> mb >>= (\\b -> p(a, b)))","title":"Proposition 2:"},{"location":"do_notation/#definition-1","text":"We call the function defined in Equation 9 above Kliesli(p) In light of the above result we can now state that a Functor equipped with a Monadic structure is necessarily equipped with an Applicative structure.","title":"Definition 1"},{"location":"do_notation/#proposition-3","text":"If p: A x B -> C is a function and M is a monad then p can be lifted to a function liftA2(p) :M A x M B -> M C making M an Applicative Functor Proof: Consider the composition eta . p : A x B ---> C ---> M C . Now apply Kliesli to get Kliesli(eta . p): M A x M B -> M C . liftA2(p) = KLiesli(eta . p)","title":"Proposition 3:"},{"location":"hask/","text":"The Hask Category All the category theory concepts used in Haskell take place in the Hask category where objects are Haskell types and arrows between two types are Haskel function between those 2 types. We will use the notation Hom(A, B) to be the set of all arrows between A and B . Cartesian Closed Categories Hask in what a category theorist would call a Cartesian Closed Category . This means the category has a products operation between object for every two objects A and B in Hask there is another object called A x B which has certain universal proterties. the is a special object, the initial object, called I such that I x A \u2245 A x I \u2245 A the category has internal Hom for every two objects A and B there is an object in the category called [A, B] such that and the following special relationship between these two operations [I, B] \u2245 B [A x B, C] \u2245 [A, [B, C]] Hom(A x B, C) \u2245 Hom(A, [B, C]) ... the Curry Isomorphism . Caveat - are types a single thing or a set of all the possible values a type can take ? For all of this to work one must squint when looking at Hask by sometimes seeing a type as a single thing and sometimes interpretting a type as the set of all possible values. Thus somethimes [A, B] is considered as the same as Hom(A, B) . This is unsatisfactory. Currying Notice that the 3rd of the above relationships is the identity that permits currying of functions. Monoidal Category A monoidal category is a category that has a binary operation between objects that is not necessarily a product . For such ccategories the x operator is replaced by a binary operator called \u2297 and does not have the universal properties of a product. Adjunction The relationships above (curry isomorphism) says that the two functors _ x B : Hask -> Hask and [B, _] : Hask -> Hask are adjoint with _ x B being left adjoint to [B, ] Unit and counit of the adjuction Take id: A x B -> A x B and apply the curry relationship to get unit: A -> [B, A x B] Similarly take id: [A, B] -> [A, B] and apply reverse currying to get counit: [A, B] x A -> B The unit function is defined as unit(a): B -> A x B such that unit(a)(b) = (a,b) The counit function is defined by counit(f, a) = f(a) . It could be called eval The curry isomporphism can be defined in terms of the unit and counit . If f: A x B -> C then its curried equivalent is the composition unit: A -> [B, A x B] followed by [B, f]: [B, A x B] -> [B, C] . Conversely g: A -> [B, C] then its reverse curry equivalent is the composition g x B: A x B -> [[B, C] x B] followed by counit: [[B, C] x B] -> C Functors between Monoidal (Or even Cartesian) Closed Categories Let F be a functor from Hask to Hask . What is the relationship between: F(A) x F(B) and F(A x B) F([A, B]) and [F(A), F(B)] In general the answer is __ there is no relationship__. But there are two special cases. Functor - Lax Monoidal The functor F is lax monoidal if 1. for all A and B there exists a function nu(A,B) :F(A) x F(B) -> F(A x B) 2. for all A there exists a function iotaA: I -> F(I) which are natural in A, B , I and satisfying a bunch of coherence rules. Functor - Lax Closed The functor F is lax closed if 1. for all A and B there exists a function zeta(A,B): F([A, B]) -> [F(A), F(B)] which is natural in A and B and satisfy some coherence conditions. Functor - In the Hask category Lax monoidal and lax closed are equivalent See https://ncatlab.org/nlab/show/closed+functor Assume F is lax monoidal. Consider nu([A, B], A): F([A, B]) x F(A) -> F([A, B] x A) and compose on the right with F(counit) to get a function: F([A, B]) x F(A) -> F(B) Now take the curried equivalent of this function to get a function F([A, B]) -> [F(A), F(B)] which is zeta(A, B) . Now assume F is lax closed. Apply F to the unit to get F(unit): F(A) -> F([B, A x B]) Now compose on the right with zeta(B, [A, B]) to get a function F(A) -> [F(B), F(A x B)] Now apply reverse currying to get F(A) x F(B) -> F(A x B) Functor - Lax monoidal = lax closed = applicative Slogans 1. Applicative Functors lift n-ary operations Let op:: A x B -> C be a binary operation. liftA2(op) = F(op) \u08aa nu(A, B) : F(A) x F(B) -> F(C) This can clearly be extended inductively to n-ary operations 2. Applicative Functors provide a lifting of curried function to curried functions Left as an exercise for the reader","title":"The Hask Category"},{"location":"hask/#the-hask-category","text":"All the category theory concepts used in Haskell take place in the Hask category where objects are Haskell types and arrows between two types are Haskel function between those 2 types. We will use the notation Hom(A, B) to be the set of all arrows between A and B .","title":"The Hask Category"},{"location":"hask/#cartesian-closed-categories","text":"Hask in what a category theorist would call a Cartesian Closed Category . This means the category has a products operation between object for every two objects A and B in Hask there is another object called A x B which has certain universal proterties. the is a special object, the initial object, called I such that I x A \u2245 A x I \u2245 A the category has internal Hom for every two objects A and B there is an object in the category called [A, B] such that and the following special relationship between these two operations [I, B] \u2245 B [A x B, C] \u2245 [A, [B, C]] Hom(A x B, C) \u2245 Hom(A, [B, C]) ... the Curry Isomorphism .","title":"Cartesian Closed Categories"},{"location":"hask/#caveat-are-types-a-single-thing-or-a-set-of-all-the-possible-values-a-type-can-take","text":"For all of this to work one must squint when looking at Hask by sometimes seeing a type as a single thing and sometimes interpretting a type as the set of all possible values. Thus somethimes [A, B] is considered as the same as Hom(A, B) . This is unsatisfactory.","title":"Caveat - are types a single thing or a set of all the possible values a type can take ?"},{"location":"hask/#currying","text":"Notice that the 3rd of the above relationships is the identity that permits currying of functions.","title":"Currying"},{"location":"hask/#monoidal-category","text":"A monoidal category is a category that has a binary operation between objects that is not necessarily a product . For such ccategories the x operator is replaced by a binary operator called \u2297 and does not have the universal properties of a product.","title":"Monoidal Category"},{"location":"hask/#adjunction","text":"The relationships above (curry isomorphism) says that the two functors _ x B : Hask -> Hask and [B, _] : Hask -> Hask are adjoint with _ x B being left adjoint to [B, ]","title":"Adjunction"},{"location":"hask/#unit-and-counit-of-the-adjuction","text":"Take id: A x B -> A x B and apply the curry relationship to get unit: A -> [B, A x B] Similarly take id: [A, B] -> [A, B] and apply reverse currying to get counit: [A, B] x A -> B The unit function is defined as unit(a): B -> A x B such that unit(a)(b) = (a,b) The counit function is defined by counit(f, a) = f(a) . It could be called eval The curry isomporphism can be defined in terms of the unit and counit . If f: A x B -> C then its curried equivalent is the composition unit: A -> [B, A x B] followed by [B, f]: [B, A x B] -> [B, C] . Conversely g: A -> [B, C] then its reverse curry equivalent is the composition g x B: A x B -> [[B, C] x B] followed by counit: [[B, C] x B] -> C","title":"Unit and counit of the adjuction"},{"location":"hask/#functors-between-monoidal-or-even-cartesian-closed-categories","text":"Let F be a functor from Hask to Hask . What is the relationship between: F(A) x F(B) and F(A x B) F([A, B]) and [F(A), F(B)] In general the answer is __ there is no relationship__. But there are two special cases.","title":"Functors between Monoidal (Or even Cartesian) Closed Categories"},{"location":"hask/#functor-lax-monoidal","text":"The functor F is lax monoidal if 1. for all A and B there exists a function nu(A,B) :F(A) x F(B) -> F(A x B) 2. for all A there exists a function iotaA: I -> F(I) which are natural in A, B , I and satisfying a bunch of coherence rules.","title":"Functor - Lax Monoidal"},{"location":"hask/#functor-lax-closed","text":"The functor F is lax closed if 1. for all A and B there exists a function zeta(A,B): F([A, B]) -> [F(A), F(B)] which is natural in A and B and satisfy some coherence conditions.","title":"Functor - Lax Closed"},{"location":"hask/#functor-in-the-hask-category-lax-monoidal-and-lax-closed-are-equivalent","text":"See https://ncatlab.org/nlab/show/closed+functor Assume F is lax monoidal. Consider nu([A, B], A): F([A, B]) x F(A) -> F([A, B] x A) and compose on the right with F(counit) to get a function: F([A, B]) x F(A) -> F(B) Now take the curried equivalent of this function to get a function F([A, B]) -> [F(A), F(B)] which is zeta(A, B) . Now assume F is lax closed. Apply F to the unit to get F(unit): F(A) -> F([B, A x B]) Now compose on the right with zeta(B, [A, B]) to get a function F(A) -> [F(B), F(A x B)] Now apply reverse currying to get F(A) x F(B) -> F(A x B)","title":"Functor - In the Hask category Lax monoidal and lax closed are equivalent"},{"location":"hask/#functor-lax-monoidal-lax-closed-applicative","text":"","title":"Functor - Lax monoidal = lax closed = applicative"},{"location":"hask/#slogans","text":"","title":"Slogans"},{"location":"hask/#1-applicative-functors-lift-n-ary-operations","text":"Let op:: A x B -> C be a binary operation. liftA2(op) = F(op) \u08aa nu(A, B) : F(A) x F(B) -> F(C) This can clearly be extended inductively to n-ary operations","title":"1. Applicative Functors lift n-ary operations"},{"location":"hask/#2-applicative-functors-provide-a-lifting-of-curried-function-to-curried-functions","text":"Left as an exercise for the reader","title":"2. Applicative Functors provide a lifting of curried function to curried functions"},{"location":"haskell/","text":"Monads and Applicatives Functor class Functor f where fmap :: (a -> b) -> f a -> f b (<$) :: a -> f b -> f a Applicative class Functor f => Applicative f where pure :: a -> m a (<*>) :: m (a->b) -> m a -> mb or liftA2 :: (a -> b -> c) -> (m a -> m b -> m c) (<*>) and liftA2 are related by the following equations: (<*>) = liftA2 id liftA2 f x y = f <$> x <*> y see Note below by RB where <$> is apply fmap and then evaluate (<$>) :: (a -> b) -> m a -> m b \\fab -> (\\ma -> fmap(fab)(ma)) Note 1 - liftA2 from <*> Regarding ```haskell liftA2 f x y = f <$> x <*> y liftA2 :: (a -> (b -> c) -> (m a -> (m b -> m c)) fmap :: (a -> (b -> c)) -> (m a -> m (b -> c)) If f :: a -> (b -> c) then fmap f :: m a -> m (b -> c) and `fmap f ma` is of type `m (b -> c)` and hence is a suitable first argument for `<*>` select a second argument `fmbc` of type `m (b -> c)` then ```haskell fmap f ma <*> fmbc is of type (m a -> m b) putting this all together liftA2 f ma fmbc = fmap f ma <*> fmbc ### NOTE 2 - <*> from liftA2 ```haskell (<*>) = liftA2 id liftA2 :: (a -> (b -> c)) -> (f a -> (f b -> f c)) lets replace a with (b -> c) liftA2 :: ((b -> c) -> (b -> c)) -> (f (b -> c) -> (f b -> f c)) now evaluate liftA2 on the identity :: (b -> c) -> (b -> c) liftA2 identity :: f (b -> c) -> (f b -> f c) as required Haskel definition of a Monad class Monad m where (>>=) :: m a -> ( a -> m b) -> m b (>>) :: m a -> m b -> m b return :: a -> m a View a Monad as an Applicative fmap fab ma = do { a <- ma ; return (fab a) } -- ma >>= (return . fab) pure a = do { return a } -- return a mfab <*> ma = do { fab <- mfab ; a <- ma ; return (fab a) } -- mfab >>= (\\ fab -> ma >>= (return . fab)) -- mfab `ap` ma Analysis of applicative definitions Let fab be a function of type a -> b . The expression return . fab is the composition fab followed by return as in a -> b -> m b Let ma be a value of type m a then we can form the value ma >>= return .fab which is a value of type m b . Call that value mb and note it depends on fab and ma . The function \\fab -> ma >>= (return . fab) is of type (a -> b) -> m b . For convenience call this function g :: (a -> b) -> m b . We take out the dependency of ma we could denote this as h: m a -> ((a -> b) -> m b) so that g is simple h evaluated at ma . For any value mfab of type m (a -> b) we can form the value mfab >>= h(ma) which is of type m b . The expression mfab >>= h(ma) is the definition of mfab <*> ma Kliesli extension The Kliesli condition is a characteristic of a monad that fully defines the monad. It states that for every f :: a -> m b there exists a unique Kliesli(f) :: m a -> m b such that f = (Kliesli(f) . return) :: a -> m am -> m b Given the Monad definition the Kliesli extension is defined as: KLiesli(f) = mu . fmap(f) :: m a -> m m b -> m b or for f::a -> m b and ma in m a Kliesli(f)(ma) = f >>= ma All function m a -> m b are KLiesli extensions Consider a map f :: m a -> m b some simple diagram chasing will demonstrate that for all ma :: (m a) kliesli(f . pure)(ma) = (\\a -> kliesli(f . pure)(ma) = f(ma) which is just another way of saying kliesli(f . pure) = f . That is the function kliesli :: (a -> m b) -> (ma -> mb) and (\\f -> f . pure) :: (m a -> m b) -> (a -> m b) constitute an isomorphism. do notation What problem does the haskell do solve. Consider you have two functions f :: X -> M A and g :: Y -> M B which do some caclulation that prepare input for a final \"bring it all together\" calculation represented by a function k :: (A, B) -> M C . As you can see all of these functions produce a Monadic result, maybe each calculation required some IO and ma have failed so M A ma equal IO Maybe A . But for the moment lets assume that M = Maybe (no IO). How would we apply k to the outcomes of f and g . In a typical imperative language we would write something like this: function combine(ma: M A, mb: M B, k: (A, B) -> M C) if(ma.isNothing() || mb.isNothing()) { return Maybe.nothing() } const a = ma.get_value() const b = mb.get_value() return k(a, b) } The problem with the above solution is that it is Maybe specific. Is there a way of doing this for a general Monad ? The haskell solution is combine :: (m a, m b, (a,b) -> m c) -> m c combine ma mb k = ma >>= (\\x -> mb >>= (\\y -> f x y)) or using do notation combine :: (m a, m b, (a,b) -> m c) -> m c combine ma mb k = do { x <- ma; y <- mb; k a b } Translating this into a hypothetical monad `M` yields (ignoring generic parameters) function combine(ma: M<A>, mb: M<B>, k: (A, B) -> M<C>) M.bind(ma, (a) => M.bind(mb, (b) => k(a,b))) } This is tested in parser_applicative.ts","title":"Haskell"},{"location":"haskell/#monads-and-applicatives","text":"","title":"Monads and Applicatives"},{"location":"haskell/#functor","text":"class Functor f where fmap :: (a -> b) -> f a -> f b (<$) :: a -> f b -> f a","title":"Functor"},{"location":"haskell/#applicative","text":"class Functor f => Applicative f where pure :: a -> m a (<*>) :: m (a->b) -> m a -> mb or liftA2 :: (a -> b -> c) -> (m a -> m b -> m c) (<*>) and liftA2 are related by the following equations: (<*>) = liftA2 id liftA2 f x y = f <$> x <*> y see Note below by RB where <$> is apply fmap and then evaluate (<$>) :: (a -> b) -> m a -> m b \\fab -> (\\ma -> fmap(fab)(ma))","title":"Applicative"},{"location":"haskell/#note-1-lifta2-from","text":"Regarding ```haskell liftA2 f x y = f <$> x <*> y liftA2 :: (a -> (b -> c) -> (m a -> (m b -> m c)) fmap :: (a -> (b -> c)) -> (m a -> m (b -> c)) If f :: a -> (b -> c) then fmap f :: m a -> m (b -> c) and `fmap f ma` is of type `m (b -> c)` and hence is a suitable first argument for `<*>` select a second argument `fmbc` of type `m (b -> c)` then ```haskell fmap f ma <*> fmbc is of type (m a -> m b) putting this all together liftA2 f ma fmbc = fmap f ma <*> fmbc ### NOTE 2 - <*> from liftA2 ```haskell (<*>) = liftA2 id liftA2 :: (a -> (b -> c)) -> (f a -> (f b -> f c)) lets replace a with (b -> c) liftA2 :: ((b -> c) -> (b -> c)) -> (f (b -> c) -> (f b -> f c)) now evaluate liftA2 on the identity :: (b -> c) -> (b -> c) liftA2 identity :: f (b -> c) -> (f b -> f c) as required","title":"Note 1 - liftA2 from &lt;*&gt;"},{"location":"haskell/#haskel-definition-of-a-monad","text":"class Monad m where (>>=) :: m a -> ( a -> m b) -> m b (>>) :: m a -> m b -> m b return :: a -> m a","title":"Haskel definition of a Monad"},{"location":"haskell/#view-a-monad-as-an-applicative","text":"fmap fab ma = do { a <- ma ; return (fab a) } -- ma >>= (return . fab) pure a = do { return a } -- return a mfab <*> ma = do { fab <- mfab ; a <- ma ; return (fab a) } -- mfab >>= (\\ fab -> ma >>= (return . fab)) -- mfab `ap` ma","title":"View a Monad as an Applicative"},{"location":"haskell/#analysis-of-applicative-definitions","text":"Let fab be a function of type a -> b . The expression return . fab is the composition fab followed by return as in a -> b -> m b Let ma be a value of type m a then we can form the value ma >>= return .fab which is a value of type m b . Call that value mb and note it depends on fab and ma . The function \\fab -> ma >>= (return . fab) is of type (a -> b) -> m b . For convenience call this function g :: (a -> b) -> m b . We take out the dependency of ma we could denote this as h: m a -> ((a -> b) -> m b) so that g is simple h evaluated at ma . For any value mfab of type m (a -> b) we can form the value mfab >>= h(ma) which is of type m b . The expression mfab >>= h(ma) is the definition of mfab <*> ma","title":"Analysis of applicative definitions"},{"location":"haskell/#kliesli-extension","text":"The Kliesli condition is a characteristic of a monad that fully defines the monad. It states that for every f :: a -> m b there exists a unique Kliesli(f) :: m a -> m b such that f = (Kliesli(f) . return) :: a -> m am -> m b Given the Monad definition the Kliesli extension is defined as: KLiesli(f) = mu . fmap(f) :: m a -> m m b -> m b or for f::a -> m b and ma in m a Kliesli(f)(ma) = f >>= ma","title":"Kliesli extension"},{"location":"haskell/#all-function-m-a-m-b-are-kliesli-extensions","text":"Consider a map f :: m a -> m b some simple diagram chasing will demonstrate that for all ma :: (m a) kliesli(f . pure)(ma) = (\\a -> kliesli(f . pure)(ma) = f(ma) which is just another way of saying kliesli(f . pure) = f . That is the function kliesli :: (a -> m b) -> (ma -> mb) and (\\f -> f . pure) :: (m a -> m b) -> (a -> m b) constitute an isomorphism.","title":"All function m a -&gt; m b are KLiesli extensions"},{"location":"haskell/#do-notation","text":"What problem does the haskell do solve. Consider you have two functions f :: X -> M A and g :: Y -> M B which do some caclulation that prepare input for a final \"bring it all together\" calculation represented by a function k :: (A, B) -> M C . As you can see all of these functions produce a Monadic result, maybe each calculation required some IO and ma have failed so M A ma equal IO Maybe A . But for the moment lets assume that M = Maybe (no IO). How would we apply k to the outcomes of f and g . In a typical imperative language we would write something like this: function combine(ma: M A, mb: M B, k: (A, B) -> M C) if(ma.isNothing() || mb.isNothing()) { return Maybe.nothing() } const a = ma.get_value() const b = mb.get_value() return k(a, b) } The problem with the above solution is that it is Maybe specific. Is there a way of doing this for a general Monad ? The haskell solution is combine :: (m a, m b, (a,b) -> m c) -> m c combine ma mb k = ma >>= (\\x -> mb >>= (\\y -> f x y)) or using do notation combine :: (m a, m b, (a,b) -> m c) -> m c combine ma mb k = do { x <- ma; y <- mb; k a b } Translating this into a hypothetical monad `M` yields (ignoring generic parameters) function combine(ma: M<A>, mb: M<B>, k: (A, B) -> M<C>) M.bind(ma, (a) => M.bind(mb, (b) => k(a,b))) } This is tested in parser_applicative.ts","title":"do notation"},{"location":"interesting_links/","text":"Interesting Links https://stackoverflow.com/questions/45712106/why-are-promises-monads https://write.yiransheng.com/callcc https://itnext.io/continuations-in-typescript-db18402010bc https://curiosity-driven.org/monads-in-javascript https://maxhallinan.com/posts/2019/10/22/how-does-the-continuation-monad-work/","title":"Interesting Links"},{"location":"interesting_links/#interesting-links","text":"https://stackoverflow.com/questions/45712106/why-are-promises-monads https://write.yiransheng.com/callcc https://itnext.io/continuations-in-typescript-db18402010bc https://curiosity-driven.org/monads-in-javascript https://maxhallinan.com/posts/2019/10/22/how-does-the-continuation-monad-work/","title":"Interesting Links"},{"location":"monad/","text":"","title":"Monad"}]}