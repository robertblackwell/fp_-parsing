{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"01_introduction/","text":"Introduction Goal This project is a personal learning exercise in which my goal is to develop a parser for arithmetic expressions using the Functional Programming/Category Theoretic machinery of Functors, Applicatives, and Monads. Motivation I have been dabbling with functional programming in Haskell and Ocaml for sometime but have found it difficult to get my head around. This is particular gauling because as well as a programmer I am (or was) a Category Theorist, and in my Doctoral Dissertation I proved some Theorems about Monads (as least Monads in a 2-category that in those days were called Doctrines). So I am very familiar with the Category Theory, but have still found Haskell's interpretation of those concepts difficult to absorb. So this project is a concerted effort to learn or at least get over the hump. I have chosen to implement this project in Typescript. It is a language I know reasonably well, has an adequate type system (for most things but as we will see not for this project) and it is a traditional enough imperative language that any programmer should be able to follow along as I implement the various concepts. Notation Comparison I believe the notation used in Haskell, Ocaml and other ML related languages get in the way of the Category Theorist in me grasping what is going on. Here is a brief discussion of the differences. FP/Haskell operates in the Hask category where objects are types (as defined by the languages type rules) and arrows are functions between types. In CT (an abbreviation for the term Category Theory) objects are upper case whereas in Haskell they are lower eg A vs a . In CT the notation A -> B represents a particular arrow/function between two objects. However Haskell has no equivalent diagramatic notation for a single arrow. The Haskell notation a -> b is a type, specifically the type of all arrows from a to b , and is another object is the Hask category. The equivalent in CT is B A or sometimes [A, B] , or sometimes A => B and is an object in the Hask category . This is what makes Hask a closed category . See more below. So if M (or m in Haskell) is a functor in CT M(A->B) is the functor applied to an arrow f:A->B . In Haskell this would be fmap(f) . On the otehrhand the equivalent Haskell notation m(a-> b) is the functor applied to the object a->b . What a CT'ist would call M([A,B]) . This is difference in the meaning of m(a->b) has definitely caused me grief and substantially slowed my understanding. CT represents the set of all arrows from A to B by Hom(A, B) . There is no equivalent in Haskell other than to say that ab is a value of type (a -> b) . Finally consider pairs. If A/a and B/b are objects in (CT/Haskell) respectively the type of all pairs is called A x B or A \u2297 B in Category Theory, and (a, b) in Haskell. Together AxB and [A, B] make Hask a catersian/monoidal closed category, which is the equiavalent of currying . An exposition as well as a parser In addition to providing typescript code that implements an Applicative and/or Monadic parser I hope to explain and document for myself the various relationships between Applicatives and Monads and their various formulations. I apologize in advance because this additional goal will force me at times to dive into the category theory and to use more CT like notation. Hence the next heading is intended to provide a bit of a reference if things get confusing. Notation for this document Objects are uppercase. This is consistent with Typescript general usage. A -> B means a specific arrow from A to B . A => B is the type of arrows from A to B . Typescript will often insist that I write is (a:A)=>B . When a discussion is mainly Category Theoretic I might use [A, B] for A=>B . Functors, Applicatives, Monads are always represented by uppercase letters or a name starting with an uppercase letter, such as Maybe . Functor application will uses angle brackets F<A> (or a Haskell like convention of F A ) is the functor F applied to the object A . This is a Typescript requirement. We might occasionally slip and write F<A->B> when we mean fmap<A->B> . We will generally write A x B as the type of pairs of [A, B] except when Typescript insists on using the second notation. A function that takes n arguments is not the same as a function that takes a single n-tuple . Nor is it the same as the function resulting from full or partial currying . These are equivalent (meaning there is an isomorphism that maps one to the other and back again) but not the same. Typescript also insists on this differentiation. Two code solutions I started this project by building a parser for arithmetic expressions using what I thought of as a FP approach but without using any of the machinery of Functors, Applicatives, Monads. At least not explicitly. I have kept that solution for the purposes of illustration and comparison in the sub directory initial-solution . To run this solution on some test cases simply enter ts-node initial-solution/main.ts My final solution using the power of Functors, Applicatives and Monads is in the src sub directory. The tests directory runs a series of unit tests of the pieces and final solution. Anatomy of the solutions Both the code solutions have broadly the same structure. A parsing function takes in a character string and produces either some indication of failure or a data structure called an Abstract Syntax Tree an Ast . This function is in the file initial-soluton/parser.ts for the initial or naive solution and the file src/parser.ts for the Categorical solution. There are type definitions and constructor functions for the Ast in the files src/tree/tree.ts and src/tree/tree.ts and these are common to both solutions. The files stc/tree/walker.ts contains functions that traverse an Ast and either evaluation the arithmetic expression or construct a canonical string representation of the Ast .","title":"Introduction"},{"location":"01_introduction/#introduction","text":"","title":"Introduction"},{"location":"01_introduction/#goal","text":"This project is a personal learning exercise in which my goal is to develop a parser for arithmetic expressions using the Functional Programming/Category Theoretic machinery of Functors, Applicatives, and Monads.","title":"Goal"},{"location":"01_introduction/#motivation","text":"I have been dabbling with functional programming in Haskell and Ocaml for sometime but have found it difficult to get my head around. This is particular gauling because as well as a programmer I am (or was) a Category Theorist, and in my Doctoral Dissertation I proved some Theorems about Monads (as least Monads in a 2-category that in those days were called Doctrines). So I am very familiar with the Category Theory, but have still found Haskell's interpretation of those concepts difficult to absorb. So this project is a concerted effort to learn or at least get over the hump. I have chosen to implement this project in Typescript. It is a language I know reasonably well, has an adequate type system (for most things but as we will see not for this project) and it is a traditional enough imperative language that any programmer should be able to follow along as I implement the various concepts.","title":"Motivation"},{"location":"01_introduction/#notation-comparison","text":"I believe the notation used in Haskell, Ocaml and other ML related languages get in the way of the Category Theorist in me grasping what is going on. Here is a brief discussion of the differences. FP/Haskell operates in the Hask category where objects are types (as defined by the languages type rules) and arrows are functions between types. In CT (an abbreviation for the term Category Theory) objects are upper case whereas in Haskell they are lower eg A vs a . In CT the notation A -> B represents a particular arrow/function between two objects. However Haskell has no equivalent diagramatic notation for a single arrow. The Haskell notation a -> b is a type, specifically the type of all arrows from a to b , and is another object is the Hask category. The equivalent in CT is B A or sometimes [A, B] , or sometimes A => B and is an object in the Hask category . This is what makes Hask a closed category . See more below. So if M (or m in Haskell) is a functor in CT M(A->B) is the functor applied to an arrow f:A->B . In Haskell this would be fmap(f) . On the otehrhand the equivalent Haskell notation m(a-> b) is the functor applied to the object a->b . What a CT'ist would call M([A,B]) . This is difference in the meaning of m(a->b) has definitely caused me grief and substantially slowed my understanding. CT represents the set of all arrows from A to B by Hom(A, B) . There is no equivalent in Haskell other than to say that ab is a value of type (a -> b) . Finally consider pairs. If A/a and B/b are objects in (CT/Haskell) respectively the type of all pairs is called A x B or A \u2297 B in Category Theory, and (a, b) in Haskell. Together AxB and [A, B] make Hask a catersian/monoidal closed category, which is the equiavalent of currying .","title":"Notation Comparison"},{"location":"01_introduction/#an-exposition-as-well-as-a-parser","text":"In addition to providing typescript code that implements an Applicative and/or Monadic parser I hope to explain and document for myself the various relationships between Applicatives and Monads and their various formulations. I apologize in advance because this additional goal will force me at times to dive into the category theory and to use more CT like notation. Hence the next heading is intended to provide a bit of a reference if things get confusing.","title":"An exposition as well as a parser"},{"location":"01_introduction/#notation-for-this-document","text":"Objects are uppercase. This is consistent with Typescript general usage. A -> B means a specific arrow from A to B . A => B is the type of arrows from A to B . Typescript will often insist that I write is (a:A)=>B . When a discussion is mainly Category Theoretic I might use [A, B] for A=>B . Functors, Applicatives, Monads are always represented by uppercase letters or a name starting with an uppercase letter, such as Maybe . Functor application will uses angle brackets F<A> (or a Haskell like convention of F A ) is the functor F applied to the object A . This is a Typescript requirement. We might occasionally slip and write F<A->B> when we mean fmap<A->B> . We will generally write A x B as the type of pairs of [A, B] except when Typescript insists on using the second notation. A function that takes n arguments is not the same as a function that takes a single n-tuple . Nor is it the same as the function resulting from full or partial currying . These are equivalent (meaning there is an isomorphism that maps one to the other and back again) but not the same. Typescript also insists on this differentiation.","title":"Notation for this document"},{"location":"01_introduction/#two-code-solutions","text":"I started this project by building a parser for arithmetic expressions using what I thought of as a FP approach but without using any of the machinery of Functors, Applicatives, Monads. At least not explicitly. I have kept that solution for the purposes of illustration and comparison in the sub directory initial-solution . To run this solution on some test cases simply enter ts-node initial-solution/main.ts My final solution using the power of Functors, Applicatives and Monads is in the src sub directory. The tests directory runs a series of unit tests of the pieces and final solution.","title":"Two code solutions"},{"location":"01_introduction/#anatomy-of-the-solutions","text":"Both the code solutions have broadly the same structure. A parsing function takes in a character string and produces either some indication of failure or a data structure called an Abstract Syntax Tree an Ast . This function is in the file initial-soluton/parser.ts for the initial or naive solution and the file src/parser.ts for the Categorical solution. There are type definitions and constructor functions for the Ast in the files src/tree/tree.ts and src/tree/tree.ts and these are common to both solutions. The files stc/tree/walker.ts contains functions that traverse an Ast and either evaluation the arithmetic expression or construct a canonical string representation of the Ast .","title":"Anatomy of the solutions"},{"location":"02_maybe_monad/","text":"Maybe Monad I am introducing this example of a Monad early in the exposition because it will be required in the next couple of section. However a full treatment of Monads will be delayed until much later in this paper. The Haskell Maybe Monad is available in many languages under the name Optional , Nullable , or Union with null. In TS we can define a type that optionally has a value as Nullable<T> which is defined as T | null . However I chose to befine a type Maybe<T> more like the definition from Haskel. class Maybe<T> { private value: T | null private constructor(v: T|null) { this.value = v } public static just(t: T): Maybe<T> { return Object.freeze(new Maybe<T>(t)) } public static nothing(): Maybe<T> { return Object.freeze(new Maybe<T>(null)) } public static isNothing(r: Maybe<T>): bool { return (r.value === null) } public static getValue(r: Maybe<T>): T { if(r.value === null) { throw Error(\"trying to be value from a nothing Maybe\") } return r.value } } The benefit of this definition is that it more closely follows the Haskel notation, and hence is an aid to understanding. Note some of the characteristics of this definition. It is not possible to make an instance of Maybe<T> that is invalid. The class constructor is private and there are only 2 constructors implemented as publis static functions. The type is opaque, the value property cannot be modified or queried except by the use of the give static function. Instances of Maybe<T> are immutable, doubly so no access to the value property and the instances are frozen.","title":"The Maybe Monad"},{"location":"02_maybe_monad/#maybe-monad","text":"I am introducing this example of a Monad early in the exposition because it will be required in the next couple of section. However a full treatment of Monads will be delayed until much later in this paper. The Haskell Maybe Monad is available in many languages under the name Optional , Nullable , or Union with null. In TS we can define a type that optionally has a value as Nullable<T> which is defined as T | null . However I chose to befine a type Maybe<T> more like the definition from Haskel. class Maybe<T> { private value: T | null private constructor(v: T|null) { this.value = v } public static just(t: T): Maybe<T> { return Object.freeze(new Maybe<T>(t)) } public static nothing(): Maybe<T> { return Object.freeze(new Maybe<T>(null)) } public static isNothing(r: Maybe<T>): bool { return (r.value === null) } public static getValue(r: Maybe<T>): T { if(r.value === null) { throw Error(\"trying to be value from a nothing Maybe\") } return r.value } } The benefit of this definition is that it more closely follows the Haskel notation, and hence is an aid to understanding. Note some of the characteristics of this definition. It is not possible to make an instance of Maybe<T> that is invalid. The class constructor is private and there are only 2 constructors implemented as publis static functions. The type is opaque, the value property cannot be modified or queried except by the use of the give static function. Instances of Maybe<T> are immutable, doubly so no access to the value property and the instances are frozen.","title":"Maybe Monad"},{"location":"02_parsing_introduction/","text":"Parsing Arithmetic Expressions Recall that the mission of this project is to build a programs that - parses arithmetic expressions into a data structure I will call an Ast , - evaluates such a data structure, - and prints such a data structure. Here is a BNF specification of arithmetic expressions: expression ::= term \"+\" expression | term term ::= factor \"*\" term | factor factor ::= number | \"(\" expression \")\" number ::= digit , number | digit digit ::= \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\" What is a parser ? If you read a Haskel text book there is a chance you will find this little rhyme: A parser for things is a functions from strings to lists of pairs of things and strings Putting this rhyme into a definition yields something like: type Parser<T> = (s: string) => Array<[T, string]> While this definition is simple I have decided, after much experimentation, that I dont like it for \"real\" programs. My reasons: returning an empty array to signal parsing failed seems like a poor approach for a Functional Programming exercise. Why not use type Optional<T> = T | Null or the Maybe Monad . See the section entitled Maybe Monad for details. I found no need for a parser to return multiple tuples in any of my experiments in this project. accessing the elements of a tupe using tup[0] and tup[1] seems error prone and difficult to change (many edit sites) Instead I decide to use the following (style) of definition. import {Maybe} from './maybe_v1' export type ParserResult<T> = {maybe_result: Maybe<T>, remaining: string} export function makeParserResult<T>(r: Maybe<T>, rem: string) { return {maybe_result: r, remaining: rem} } export type Parser<T> = (sinput: string) => {maybe_result: Maybe<T>, remaining: string}","title":"Parsing"},{"location":"02_parsing_introduction/#parsing","text":"","title":"Parsing"},{"location":"02_parsing_introduction/#arithmetic-expressions","text":"Recall that the mission of this project is to build a programs that - parses arithmetic expressions into a data structure I will call an Ast , - evaluates such a data structure, - and prints such a data structure. Here is a BNF specification of arithmetic expressions: expression ::= term \"+\" expression | term term ::= factor \"*\" term | factor factor ::= number | \"(\" expression \")\" number ::= digit , number | digit digit ::= \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\"","title":"Arithmetic Expressions"},{"location":"02_parsing_introduction/#what-is-a-parser","text":"If you read a Haskel text book there is a chance you will find this little rhyme: A parser for things is a functions from strings to lists of pairs of things and strings Putting this rhyme into a definition yields something like: type Parser<T> = (s: string) => Array<[T, string]> While this definition is simple I have decided, after much experimentation, that I dont like it for \"real\" programs. My reasons: returning an empty array to signal parsing failed seems like a poor approach for a Functional Programming exercise. Why not use type Optional<T> = T | Null or the Maybe Monad . See the section entitled Maybe Monad for details. I found no need for a parser to return multiple tuples in any of my experiments in this project. accessing the elements of a tupe using tup[0] and tup[1] seems error prone and difficult to change (many edit sites) Instead I decide to use the following (style) of definition. import {Maybe} from './maybe_v1' export type ParserResult<T> = {maybe_result: Maybe<T>, remaining: string} export function makeParserResult<T>(r: Maybe<T>, rem: string) { return {maybe_result: r, remaining: rem} } export type Parser<T> = (sinput: string) => {maybe_result: Maybe<T>, remaining: string}","title":"What is a parser ?"},{"location":"03_building_parsers/","text":"Combining Parsers It will turn out that our goal of building a parser for arithmetic expressions will be achieved by combining simpler or more elementary parsers in a number of ways. Single Character Parsers The simplest parser of all is one that successfully parser any single character. Thus our first example of a parser below is one that parses any single character whether or not preceeded by whitespace. /** * Match any single non-whitespace character */ function parseAnyChar<string>(sinput: string): {maybe_result: Maybe<string>, remaining: string} { const s = removewhitespace(sinput) if(sinput.length ==0) return {maybe_result: Maybe.nothing(), remaining: sinput} const value = s.substring(0,1) const remainder = s.slice(1) return {maybe_result: Maybe.just(value), remaining: remainder} } This can trivially be modified to provide a parse that can successfully parse any single digit. Note we have not consumed leading whitespace. /** * Parse a digit without consuming leading white space */ function parseSingleDigit(sinput string): {maybe_result: Maybe<string>, remaining: string} { const s = sinput.slice(0) if((s.length == 0) || (s.substring(0, 1).match(/[0-9]/g) == null) { return makeParserResult(Maybe.nothing(), remaining) } const value = s.substring(0,1) const remainder = s.slice(1) return makeParserResult(Maybe.just(value), remainder) } It will turnout that a parser that can parse any single character that satisfies a boolean predicate is a very useful tool. /** * Return a parser that parses the next single character in the input if it satisfies * a predicate */ function createPredicateParser(predicate (ch: string) => boolean): Parser<string> { return function(s: string){ if((sinput.length == 0) || (! predicate(s.substring(0,1)))) return {maybe_result: Maybe.nothing(), remaining: sinput} const value = s.substring(0,1) const remainder = s.slice(1) return {maybe_result: Maybe.just(value), remaining: remainder} } } As the final example of this section we will make a parser that successfully parser a single whitespace character; const oneWhitespaceCharacterParser = createPredicateParser((ss) => ss.substring(0,1).match(/[\\s]/g) ) The One-or-more parser Its clear that in order to parser arithmentic expression we will need to be able to parse numbers which are a sequence of one or more digits. Above we have a parser that can parse single digits. How to we use that to parse a sequence of one or more digits. This is what I think of as the one-or-more parser. /* * Take a parser for a single character meeting some criteria and return * a parser that detects greater than zero consecutive instances of such characters */ function create_OneOrMoreParser(singleChParser: Parser<string>): Parser<string> { function functionManyTimes(sinput: string) => { let s = sinput.slice(0) const r = singleChParser(s) let parse_result = \"\" if(Maybe.isNothing(r)) { return Maybe.nothing() } const pair = Maybe.get_value(r) const first_ok_char_as_str = pair.value const remain = pair.remaining_input const r2 = manyTimes(remain) if(Maybe.isNothing(r2)) { return Maybe.nothing() } const result_pair = Maybe.get_value(r2) const subsequent_ok_chars_as_string = result_pair.value const parse_result_string = first_digit_as_string + subsequent_digits_as_string return Maybe.just(PPairClass.make(parse_result, pair2.remaining_input)) } return functionManyTimes } The experienced Haskel programmer will observe that the create_OneOrMoreParser() could have used more of the Monad properties of the Maybe Monad . We will come back to that eventually. The one-or-more constructor makes parsing numbers (a string consisting only of digits) easy. As below. function parseNumber(sinput: string): Maybe<PPairClass<string>> { const digitParser = createPredicateParser((ss: string) => (ss.substring(0, 1).match(/[0-9]/g))) const numParser = create_OneOrMoreParser(digitParser) return numParser(s) } As a second example of the use of the create_OneOrMoreParser() lets make a parser that can successfully parse uppercase words (sequences of upper case letters). function parseUppercaseWords(sinput: string): Maybe<PPairClass<string>> { const upperCaseLetterParser = createPredicateParser((ss: string) => (ss.substring(0, 1).match(/[A-Z]/g))) const upperCaseWordParser = create_OneOrMoreParser(upperCaseLetterParser) return upperCaseWordParser(s) } Whitespace The following strings 2 + 3* (4 + 1) and 2+3*(4+1) are equivalent as arithmetic expressions because whitespace between the terms does not change the interpretation of the expression. Thus we have a decision to make. When we parse expressions do we keep track of the white space so that the exact input string can be recreated froom the Ast (such as string 1 above), do we use eliminate whitespace during the parsing process like in string 2 above, or maybe reduce each sequence of whitespace to a single space character like 2 + 3 * ( 4 + 1 ) . We will chose to eliminate whitespace. Before continuing lets make a function that parses a sequence of whitespace. const whitespaceParser = create_OneOrMoreParser(oneWhitespaceCharParser) Hence many of the parser function we design will be required to eliminate all whitespace from the front of their input string before attempting to parse an input string. Consider a parser const p: (sinput: string) => Maybe<PP<T>> . Here is a function that converts that parser p to a new parser that strips whitespace from the front of the input string. function whitespaceIfy(p (sinput: string) => Maybe<PP<T>>) (sinput: string) => Maybe<PP<T>> { return function(sinput: string): Maybe<PP<T>> { const r = whitespaceParser(sinput) const sin = (Maybe.isNothing(r)) ? sinput: Maybe.get_remainder(r) return p(sin) } } Alternatives or - the OR parser Consider that task of parsing strings which are either numbers, a sequence of digits capitalized words, a sequence of uppercase letters This can be achieved by: first applying parseNumber() and if successfull its return value is the return value of our desired parser. if parseNumber() fails then apply parseUppercaseWords() and use its return value. In code this looks like: function parseNumberOrUppercaseWord(sinput string): Maybe<PPairClass<string>> { const r1 = parserNumber(sinput) if(Maybe.isNothing(r1)) { const r2 = parseUppercaseWord(sinput) if(Maybe.isNothing(r2)) return Maybe.nothing<string>() const numb = r2.get_value() return Maybe.just<string>(numb)) } const s string = r1.get_value() return Maybe.just<string>(s) } Infact this is a general construct. Given two parsers: const p1: (s string) => Maybe<PPairClass<T>> const p2: (s string) => Maybe<PPairClass<R>> We can get a p1_OR_p2 parser as follows: function OR_parser(p1 (s string) => Maybe<PPairClass<T>>, p2 (s string) => Maybe<PPairClass<R>>): (s string) => Maybe<PPairClass<T|R>> { return function(sinput string): Maybe<PPairCase<T|R>> { const r1 = parserNumber(sinput) if(Maybe.isNothing(r1)) { const r2 = parseUppercaseWord(sinput) if(Maybe.isNothing(r2)) return Maybe.nothing<T|R>() const v2 R = r2.get_value() return Maybe.just<T|R>(v2)) } const tvalue T = r1.get_value() return Maybe.just<T|R>(s) } } The Followed-By Parser Lets make a function that will parser variable names. Variable names: must start with an upper or lower case letter or an underscore _ thereafter there may be zero of more characters that are either digits, uppercase letters, lowercase letters or underscores. Its pretty clear that we can do this by first parsing the initial character with const firstCharParser = createPredicateParser((s) => (s.substring(0, 1).match(/[a-zA-Z_]/g)) ) and then parsing all of the remaining characters with: const subsequentCharParser = create_OneOrMoreParser(createPredicateParser((s) => (s.substring(0, 1).match(/[a-zA-Z_]/g)))) So now lets turn our attention to creating a function that combines firstCharParser and sunsequentCharParser as described above. function variableNameParser(sinput: string): Maybe<PP<string>> { const r1 = firstCharParser(sinput) if(Maybe.isNothing(r1)) { return r1 } return subsequentCharParser(Maybe.get_value(r1)) } Again this can be generalized as: function followedBy(p1: (sinput: string)=>Maybe<PP<T>>, p2:(sinput: string) => Maybe<PP<T>>): (sinput: string) => Maybe<PP<T>> { const r1 = p1(sinput) if(Maybe.isNothing(r1)) { return r1 } return p2(Maybe.get_value(r1)) } Remembering that Parser<T> = (sinput: string) => Maybe<PP<T>> we can generalize followedBy from a binary operation to an array operation. Such that a list of parsers can be applied one after the other. /** * You might recongnize this as a left_fold operation */ function sequence(ps: Array<Parser<T>>): Parser<T> { let p_accum = ps[0] ps[1:].foreach((pnext) => { p_accum = followedBy(p_accum, pnext) }) }","title":"Combining Parsers"},{"location":"03_building_parsers/#combining-parsers","text":"It will turn out that our goal of building a parser for arithmetic expressions will be achieved by combining simpler or more elementary parsers in a number of ways.","title":"Combining Parsers"},{"location":"03_building_parsers/#single-character-parsers","text":"The simplest parser of all is one that successfully parser any single character. Thus our first example of a parser below is one that parses any single character whether or not preceeded by whitespace. /** * Match any single non-whitespace character */ function parseAnyChar<string>(sinput: string): {maybe_result: Maybe<string>, remaining: string} { const s = removewhitespace(sinput) if(sinput.length ==0) return {maybe_result: Maybe.nothing(), remaining: sinput} const value = s.substring(0,1) const remainder = s.slice(1) return {maybe_result: Maybe.just(value), remaining: remainder} } This can trivially be modified to provide a parse that can successfully parse any single digit. Note we have not consumed leading whitespace. /** * Parse a digit without consuming leading white space */ function parseSingleDigit(sinput string): {maybe_result: Maybe<string>, remaining: string} { const s = sinput.slice(0) if((s.length == 0) || (s.substring(0, 1).match(/[0-9]/g) == null) { return makeParserResult(Maybe.nothing(), remaining) } const value = s.substring(0,1) const remainder = s.slice(1) return makeParserResult(Maybe.just(value), remainder) } It will turnout that a parser that can parse any single character that satisfies a boolean predicate is a very useful tool. /** * Return a parser that parses the next single character in the input if it satisfies * a predicate */ function createPredicateParser(predicate (ch: string) => boolean): Parser<string> { return function(s: string){ if((sinput.length == 0) || (! predicate(s.substring(0,1)))) return {maybe_result: Maybe.nothing(), remaining: sinput} const value = s.substring(0,1) const remainder = s.slice(1) return {maybe_result: Maybe.just(value), remaining: remainder} } } As the final example of this section we will make a parser that successfully parser a single whitespace character; const oneWhitespaceCharacterParser = createPredicateParser((ss) => ss.substring(0,1).match(/[\\s]/g) )","title":"Single Character Parsers"},{"location":"03_building_parsers/#the-one-or-more-parser","text":"Its clear that in order to parser arithmentic expression we will need to be able to parse numbers which are a sequence of one or more digits. Above we have a parser that can parse single digits. How to we use that to parse a sequence of one or more digits. This is what I think of as the one-or-more parser. /* * Take a parser for a single character meeting some criteria and return * a parser that detects greater than zero consecutive instances of such characters */ function create_OneOrMoreParser(singleChParser: Parser<string>): Parser<string> { function functionManyTimes(sinput: string) => { let s = sinput.slice(0) const r = singleChParser(s) let parse_result = \"\" if(Maybe.isNothing(r)) { return Maybe.nothing() } const pair = Maybe.get_value(r) const first_ok_char_as_str = pair.value const remain = pair.remaining_input const r2 = manyTimes(remain) if(Maybe.isNothing(r2)) { return Maybe.nothing() } const result_pair = Maybe.get_value(r2) const subsequent_ok_chars_as_string = result_pair.value const parse_result_string = first_digit_as_string + subsequent_digits_as_string return Maybe.just(PPairClass.make(parse_result, pair2.remaining_input)) } return functionManyTimes } The experienced Haskel programmer will observe that the create_OneOrMoreParser() could have used more of the Monad properties of the Maybe Monad . We will come back to that eventually. The one-or-more constructor makes parsing numbers (a string consisting only of digits) easy. As below. function parseNumber(sinput: string): Maybe<PPairClass<string>> { const digitParser = createPredicateParser((ss: string) => (ss.substring(0, 1).match(/[0-9]/g))) const numParser = create_OneOrMoreParser(digitParser) return numParser(s) } As a second example of the use of the create_OneOrMoreParser() lets make a parser that can successfully parse uppercase words (sequences of upper case letters). function parseUppercaseWords(sinput: string): Maybe<PPairClass<string>> { const upperCaseLetterParser = createPredicateParser((ss: string) => (ss.substring(0, 1).match(/[A-Z]/g))) const upperCaseWordParser = create_OneOrMoreParser(upperCaseLetterParser) return upperCaseWordParser(s) }","title":"The One-or-more parser"},{"location":"03_building_parsers/#whitespace","text":"The following strings 2 + 3* (4 + 1) and 2+3*(4+1) are equivalent as arithmetic expressions because whitespace between the terms does not change the interpretation of the expression. Thus we have a decision to make. When we parse expressions do we keep track of the white space so that the exact input string can be recreated froom the Ast (such as string 1 above), do we use eliminate whitespace during the parsing process like in string 2 above, or maybe reduce each sequence of whitespace to a single space character like 2 + 3 * ( 4 + 1 ) . We will chose to eliminate whitespace. Before continuing lets make a function that parses a sequence of whitespace. const whitespaceParser = create_OneOrMoreParser(oneWhitespaceCharParser) Hence many of the parser function we design will be required to eliminate all whitespace from the front of their input string before attempting to parse an input string. Consider a parser const p: (sinput: string) => Maybe<PP<T>> . Here is a function that converts that parser p to a new parser that strips whitespace from the front of the input string. function whitespaceIfy(p (sinput: string) => Maybe<PP<T>>) (sinput: string) => Maybe<PP<T>> { return function(sinput: string): Maybe<PP<T>> { const r = whitespaceParser(sinput) const sin = (Maybe.isNothing(r)) ? sinput: Maybe.get_remainder(r) return p(sin) } }","title":"Whitespace"},{"location":"03_building_parsers/#alternatives-or-the-or-parser","text":"Consider that task of parsing strings which are either numbers, a sequence of digits capitalized words, a sequence of uppercase letters This can be achieved by: first applying parseNumber() and if successfull its return value is the return value of our desired parser. if parseNumber() fails then apply parseUppercaseWords() and use its return value. In code this looks like: function parseNumberOrUppercaseWord(sinput string): Maybe<PPairClass<string>> { const r1 = parserNumber(sinput) if(Maybe.isNothing(r1)) { const r2 = parseUppercaseWord(sinput) if(Maybe.isNothing(r2)) return Maybe.nothing<string>() const numb = r2.get_value() return Maybe.just<string>(numb)) } const s string = r1.get_value() return Maybe.just<string>(s) } Infact this is a general construct. Given two parsers: const p1: (s string) => Maybe<PPairClass<T>> const p2: (s string) => Maybe<PPairClass<R>> We can get a p1_OR_p2 parser as follows: function OR_parser(p1 (s string) => Maybe<PPairClass<T>>, p2 (s string) => Maybe<PPairClass<R>>): (s string) => Maybe<PPairClass<T|R>> { return function(sinput string): Maybe<PPairCase<T|R>> { const r1 = parserNumber(sinput) if(Maybe.isNothing(r1)) { const r2 = parseUppercaseWord(sinput) if(Maybe.isNothing(r2)) return Maybe.nothing<T|R>() const v2 R = r2.get_value() return Maybe.just<T|R>(v2)) } const tvalue T = r1.get_value() return Maybe.just<T|R>(s) } }","title":"Alternatives or - the OR parser"},{"location":"03_building_parsers/#the-followed-by-parser","text":"Lets make a function that will parser variable names. Variable names: must start with an upper or lower case letter or an underscore _ thereafter there may be zero of more characters that are either digits, uppercase letters, lowercase letters or underscores. Its pretty clear that we can do this by first parsing the initial character with const firstCharParser = createPredicateParser((s) => (s.substring(0, 1).match(/[a-zA-Z_]/g)) ) and then parsing all of the remaining characters with: const subsequentCharParser = create_OneOrMoreParser(createPredicateParser((s) => (s.substring(0, 1).match(/[a-zA-Z_]/g)))) So now lets turn our attention to creating a function that combines firstCharParser and sunsequentCharParser as described above. function variableNameParser(sinput: string): Maybe<PP<string>> { const r1 = firstCharParser(sinput) if(Maybe.isNothing(r1)) { return r1 } return subsequentCharParser(Maybe.get_value(r1)) } Again this can be generalized as: function followedBy(p1: (sinput: string)=>Maybe<PP<T>>, p2:(sinput: string) => Maybe<PP<T>>): (sinput: string) => Maybe<PP<T>> { const r1 = p1(sinput) if(Maybe.isNothing(r1)) { return r1 } return p2(Maybe.get_value(r1)) } Remembering that Parser<T> = (sinput: string) => Maybe<PP<T>> we can generalize followedBy from a binary operation to an array operation. Such that a list of parsers can be applied one after the other. /** * You might recongnize this as a left_fold operation */ function sequence(ps: Array<Parser<T>>): Parser<T> { let p_accum = ps[0] ps[1:].foreach((pnext) => { p_accum = followedBy(p_accum, pnext) }) }","title":"The Followed-By Parser"},{"location":"03_combining_parsers/","text":"Combining Parsers It will turn out that our goal of building a parser for arithmetic expressions will be achieved by combining simpler or more elementary parsers in a number of ways. Single Character Parsers The simplest parser of all is one that successfully parser any single character. Thus our first example of a parser below is one that parses any single character whether or not preceeded by whitespace. /** * Match any single non-whitespace character */ function parseAnyChar(sinput: string): {maybe_result: Maybe<string>, remaining: string} { if(sinput.length ==0) return {maybe_result: Maybe.nothing(), remaining: sinput} const value = sinput.substring(0,1) const remainder = sinput.slice(1) return {maybe_result: Maybe.just(value), remaining: remainder} } This can trivially be modified to provide a parse that can successfully parse any single digit. Note we have not consumed leading whitespace. /** * Parse a digit without consuming leading white space */ function parseSingleDigit(sinput: string): {maybe_result: Maybe<string>, remaining: string} { const s = sinput.slice(0) if((s.length == 0) || (s.substring(0, 1).match(/[0-9]/g) == null)) { return makeParserResult(Maybe.nothing(), sinput) } const value = s.substring(0,1) const remainder = s.slice(1) return makeParserResult(Maybe.just(value), remainder) } It will turnout that a parser that can parse any single character that satisfies a boolean predicate is a very useful tool. /** * Return a parser that parses the next single character in the input if it satisfies * a predicate */ function createPredicateParser(predicate: (ch: string) => boolean): Parser<string> { return function(sinput: string){ if((sinput.length == 0) || (! predicate(sinput.substring(0,1)))) return makeParserResult(Maybe.nothing(), sinput) const value = sinput.substring(0,1) const remainder = sinput.slice(1) return makeParserResult(Maybe.just(value), remainder) } } As the final example of this section we will make a parser that successfully parser a single whitespace character; const oneWhitespaceCharacterParser = createPredicateParser((ss) => (ss.substring(0,1).match(/[\\s]/g) !== null)) The One-or-more parser Its clear that in order to parser arithmentic expression we will need to be able to parse numbers which are a sequence of one or more digits. Above we have a parser that can parse single digits. How to we use that to parse a sequence of one or more digits. This is what I think of as the one-or-more parser. /* * Take a parser for a single character meeting some criteria and return * a parser that detects greater than zero consecutive instances of such characters */ function create_OneOrMoreParser(singleChParser: Parser<string>): Parser<string> { return function manyTimes(sinput: string): ParserResult<string> { let s = sinput.slice(0) const {maybe_result: v1, remaining: r1} = singleChParser(s) let parse_result = \"\" if(Maybe.isNothing(v1)) { return makeParserResult(Maybe.nothing(), r1) } else { // const pair = Maybe.get_value(r) const first_digit_as_string = Maybe.getValue(v1) // const remain = pair.remaining_input const {maybe_result:v2, remaining:r2} = manyTimes(r1) if(Maybe.isNothing(v2)) { return makeParserResult(Maybe.just(first_digit_as_string), r1) } // const result_pair = Maybe.get_value(r2) const subsequent_digits_as_string = Maybe.getValue(v2) const parse_result_string = first_digit_as_string + subsequent_digits_as_string return makeParserResult(Maybe.just(parse_result_string), r2) } } } The experienced Haskel programmer will observe that the create_OneOrMoreParser() could have used more of the Monad properties of the Maybe Monad . We will come back to that eventually. The one-or-more constructor makes parsing numbers (a string consisting only of digits) easy. As below. function parseNumber(sinput: string): ParserResult<string> { const digitParser = createPredicateParser((ss: string) => (ss.substring(0, 1).match(/[0-9]/g) !== null)) const numParser = create_OneOrMoreParser(digitParser) const r = numParser(sinput) return r } As a second example of the use of the create_OneOrMoreParser() lets make a parser that can successfully parse uppercase words (sequences of upper case letters). function parseUppercaseWord(sinput: string): ParserResult<string> { const upperCaseLetterParser = createPredicateParser((ss: string) => (ss.substring(0, 1).match(/[A-Z]/g) !== null)) const upperCaseWordParser = create_OneOrMoreParser(upperCaseLetterParser) return upperCaseWordParser(sinput) } Whitespace The following strings 2 + 3* (4 + 1) and 2+3*(4+1) are equivalent as arithmetic expressions because whitespace between the terms does not change the interpretation of the expression. Thus we have a decision to make. When we parse expressions do we keep track of the white space so that the exact input string can be recreated from the Ast (such as string 1 above), do we use eliminate whitespace during the parsing process like in string 2 above, or maybe reduce each sequence of whitespace to a single space character like 2 + 3 * ( 4 + 1 ) . We will chose to eliminate whitespace. Next we demonstrate how to transform any parser into a parser that ignores leading whitespace. function isWhitespaceChar(ch: string) {return (ch.substring(0,1).match(/[\\s]/g) !== null)} const oneWhitespaceCharParser = createPredicateParser(isWhitespaceChar) const whitespaceParser = create_OneOrMoreParser(oneWhitespaceCharParser) function stripLeadingWhitespace(sinput: string): string { let tmp = sinput.slice(0) while(true) { if(isWhitespaceChar(tmp[0])) { tmp = tmp.slice(1) } else { break } } return tmp } Hence many of the parser function we design will be required to eliminate all whitespace from the front of their input string before attempting to parse an input string. Consider a parser const p: (sinput: string) => Maybe<PP<T>> . Here is a function that converts that parser p to a new parser that strips whitespace from the front of the input string. function whitespaceIfy<T>(p: Parser<T>): Parser<T> { return function(sinput: string): ParserResult<T> { return p(stripLeadingWhitespace(sinput)) } } Alternatives or - the OR parser Consider the task of parsing strings which are either numbers, a sequence of digits capitalized words, a sequence of uppercase letters This can be achieved by: first applying parseNumber() and if successfull its return value is the return value of our desired parser. if parseNumber() fails then apply parseUppercaseWords() and use its return value. In code this looks like: function parseNumberOrUppercaseWord(sinput: string): ParserResult<string> { const {maybe_result, remaining} = parseNumber(sinput) if(Maybe.isNothing(maybe_result)) { const {maybe_result:v, remaining:rem} = parseUppercaseWord(sinput) if(Maybe.isNothing(v)) return makeParserResult(Maybe.nothing<string>(), remaining) const numbstr = Maybe.getValue(v) return makeParserResult(Maybe.just<string>(numbstr), rem) } const s: string = Maybe.getValue(maybe_result) return makeParserResult(Maybe.just<string>(s), remaining) } Infact this is a general construct. Given two parsers: const p1: (s string) => Maybe<PPairClass<T>> const p2: (s string) => Maybe<PPairClass<R>> We can get a p1_OR_p2 parser as follows: function OR_parser<T,R>(p1: Parser<T>, p2: Parser<R>): Parser<T|R> { return function(sinput: string): ParserResult<T|R> { const {maybe_result:v1, remaining:r1} = p1(sinput) if(Maybe.isNothing(v1)) { const {maybe_result:v2, remaining:r2} = p2(sinput) if(Maybe.isNothing(v2)) return makeParserResult(Maybe.nothing<T|R>(), r2) else { const vv = Maybe.getValue(v2) return makeParserResult(Maybe.just<T|R>(vv), r2) } } const tvalue = Maybe.getValue(v1) return makeParserResult(Maybe.just<T|R>(tvalue), r1) } } The Followed-By Parser Lets make a function that will parser variable names. Variable names: must start with an upper or lower case letter or an underscore _ thereafter there may be zero of more characters that are either digits, uppercase letters, lowercase letters or underscores. Its pretty clear that we can do this by first parsing the initial character with function isValidFirstChar(s: string): boolean {return (s.substring(0, 1).match(/[a-zA-Z_]/g) !== null)} function isValidSubsequentChar(s: string): boolean {return (s.substring(0, 1).match(/[a-zA-Z0-9_]/g) !== null)} const firstCharParser = createPredicateParser(isValidFirstChar) and then parsing all of the remaining characters with: const subsequentCharsParser = create_OneOrMoreParser(createPredicateParser(isValidSubsequentChar)) So now lets turn our attention to creating a function that combines firstCharParser and sunsequentCharParser as described above. function parseVariableName(sinput: string): ParserResult<string> { const {maybe_result:v1, remaining:r1} = firstCharParser(sinput) if(Maybe.isNothing(v1)) { return makeParserResult(Maybe.nothing(), r1) } const first_char = Maybe.getValue(v1) const {maybe_result: v2, remaining:r2} = subsequentCharsParser(r1) if(Maybe.isNothing(v2)) { return makeParserResult(Maybe.nothing(), sinput) } const subsequent_chars = Maybe.getValue(v2) return makeParserResult(Maybe.just(first_char + subsequent_chars), r2) } Again this can be generalized as: function followedBy<T, U>(p1: Parser<T>, p2: Parser<U>): Parser<[T,U]> { return function(sinput: string) { const {maybe_result: v1, remaining: r1} = p1(sinput) if(Maybe.isNothing(v1)) { return makeParserResult(Maybe.nothing(), r1) } const t1 = Maybe.getValue(v1) const {maybe_result: v2, remaining: r2} = p2(r1) if(Maybe.isNothing(v2)) { return makeParserResult(Maybe.nothing(), sinput) } const u1 = Maybe.getValue(v2) return makeParserResult(Maybe.just([t1, u1]), r2) } } Remembering that Parser<T> = (sinput: string) => Maybe<PP<T>> we can generalize followedBy from a binary operation to an array operation. Such that a list of parsers can be applied one after the other. /** * You might recognize this as a left_fold operation */ // function sequence<T>(ps: Array<Parser<T>>): Parser<T> { // let p_accum = ps[0] // ps.slice(1).forEach((pnext) => { // p_accum = followedBy(p_accum, pnext) // }) // return p_accum // }","title":"03 combining parsers"},{"location":"03_combining_parsers/#combining-parsers","text":"It will turn out that our goal of building a parser for arithmetic expressions will be achieved by combining simpler or more elementary parsers in a number of ways.","title":"Combining Parsers"},{"location":"03_combining_parsers/#single-character-parsers","text":"The simplest parser of all is one that successfully parser any single character. Thus our first example of a parser below is one that parses any single character whether or not preceeded by whitespace. /** * Match any single non-whitespace character */ function parseAnyChar(sinput: string): {maybe_result: Maybe<string>, remaining: string} { if(sinput.length ==0) return {maybe_result: Maybe.nothing(), remaining: sinput} const value = sinput.substring(0,1) const remainder = sinput.slice(1) return {maybe_result: Maybe.just(value), remaining: remainder} } This can trivially be modified to provide a parse that can successfully parse any single digit. Note we have not consumed leading whitespace. /** * Parse a digit without consuming leading white space */ function parseSingleDigit(sinput: string): {maybe_result: Maybe<string>, remaining: string} { const s = sinput.slice(0) if((s.length == 0) || (s.substring(0, 1).match(/[0-9]/g) == null)) { return makeParserResult(Maybe.nothing(), sinput) } const value = s.substring(0,1) const remainder = s.slice(1) return makeParserResult(Maybe.just(value), remainder) } It will turnout that a parser that can parse any single character that satisfies a boolean predicate is a very useful tool. /** * Return a parser that parses the next single character in the input if it satisfies * a predicate */ function createPredicateParser(predicate: (ch: string) => boolean): Parser<string> { return function(sinput: string){ if((sinput.length == 0) || (! predicate(sinput.substring(0,1)))) return makeParserResult(Maybe.nothing(), sinput) const value = sinput.substring(0,1) const remainder = sinput.slice(1) return makeParserResult(Maybe.just(value), remainder) } } As the final example of this section we will make a parser that successfully parser a single whitespace character; const oneWhitespaceCharacterParser = createPredicateParser((ss) => (ss.substring(0,1).match(/[\\s]/g) !== null))","title":"Single Character Parsers"},{"location":"03_combining_parsers/#the-one-or-more-parser","text":"Its clear that in order to parser arithmentic expression we will need to be able to parse numbers which are a sequence of one or more digits. Above we have a parser that can parse single digits. How to we use that to parse a sequence of one or more digits. This is what I think of as the one-or-more parser. /* * Take a parser for a single character meeting some criteria and return * a parser that detects greater than zero consecutive instances of such characters */ function create_OneOrMoreParser(singleChParser: Parser<string>): Parser<string> { return function manyTimes(sinput: string): ParserResult<string> { let s = sinput.slice(0) const {maybe_result: v1, remaining: r1} = singleChParser(s) let parse_result = \"\" if(Maybe.isNothing(v1)) { return makeParserResult(Maybe.nothing(), r1) } else { // const pair = Maybe.get_value(r) const first_digit_as_string = Maybe.getValue(v1) // const remain = pair.remaining_input const {maybe_result:v2, remaining:r2} = manyTimes(r1) if(Maybe.isNothing(v2)) { return makeParserResult(Maybe.just(first_digit_as_string), r1) } // const result_pair = Maybe.get_value(r2) const subsequent_digits_as_string = Maybe.getValue(v2) const parse_result_string = first_digit_as_string + subsequent_digits_as_string return makeParserResult(Maybe.just(parse_result_string), r2) } } } The experienced Haskel programmer will observe that the create_OneOrMoreParser() could have used more of the Monad properties of the Maybe Monad . We will come back to that eventually. The one-or-more constructor makes parsing numbers (a string consisting only of digits) easy. As below. function parseNumber(sinput: string): ParserResult<string> { const digitParser = createPredicateParser((ss: string) => (ss.substring(0, 1).match(/[0-9]/g) !== null)) const numParser = create_OneOrMoreParser(digitParser) const r = numParser(sinput) return r } As a second example of the use of the create_OneOrMoreParser() lets make a parser that can successfully parse uppercase words (sequences of upper case letters). function parseUppercaseWord(sinput: string): ParserResult<string> { const upperCaseLetterParser = createPredicateParser((ss: string) => (ss.substring(0, 1).match(/[A-Z]/g) !== null)) const upperCaseWordParser = create_OneOrMoreParser(upperCaseLetterParser) return upperCaseWordParser(sinput) }","title":"The One-or-more parser"},{"location":"03_combining_parsers/#whitespace","text":"The following strings 2 + 3* (4 + 1) and 2+3*(4+1) are equivalent as arithmetic expressions because whitespace between the terms does not change the interpretation of the expression. Thus we have a decision to make. When we parse expressions do we keep track of the white space so that the exact input string can be recreated from the Ast (such as string 1 above), do we use eliminate whitespace during the parsing process like in string 2 above, or maybe reduce each sequence of whitespace to a single space character like 2 + 3 * ( 4 + 1 ) . We will chose to eliminate whitespace. Next we demonstrate how to transform any parser into a parser that ignores leading whitespace. function isWhitespaceChar(ch: string) {return (ch.substring(0,1).match(/[\\s]/g) !== null)} const oneWhitespaceCharParser = createPredicateParser(isWhitespaceChar) const whitespaceParser = create_OneOrMoreParser(oneWhitespaceCharParser) function stripLeadingWhitespace(sinput: string): string { let tmp = sinput.slice(0) while(true) { if(isWhitespaceChar(tmp[0])) { tmp = tmp.slice(1) } else { break } } return tmp } Hence many of the parser function we design will be required to eliminate all whitespace from the front of their input string before attempting to parse an input string. Consider a parser const p: (sinput: string) => Maybe<PP<T>> . Here is a function that converts that parser p to a new parser that strips whitespace from the front of the input string. function whitespaceIfy<T>(p: Parser<T>): Parser<T> { return function(sinput: string): ParserResult<T> { return p(stripLeadingWhitespace(sinput)) } }","title":"Whitespace"},{"location":"03_combining_parsers/#alternatives-or-the-or-parser","text":"Consider the task of parsing strings which are either numbers, a sequence of digits capitalized words, a sequence of uppercase letters This can be achieved by: first applying parseNumber() and if successfull its return value is the return value of our desired parser. if parseNumber() fails then apply parseUppercaseWords() and use its return value. In code this looks like: function parseNumberOrUppercaseWord(sinput: string): ParserResult<string> { const {maybe_result, remaining} = parseNumber(sinput) if(Maybe.isNothing(maybe_result)) { const {maybe_result:v, remaining:rem} = parseUppercaseWord(sinput) if(Maybe.isNothing(v)) return makeParserResult(Maybe.nothing<string>(), remaining) const numbstr = Maybe.getValue(v) return makeParserResult(Maybe.just<string>(numbstr), rem) } const s: string = Maybe.getValue(maybe_result) return makeParserResult(Maybe.just<string>(s), remaining) } Infact this is a general construct. Given two parsers: const p1: (s string) => Maybe<PPairClass<T>> const p2: (s string) => Maybe<PPairClass<R>> We can get a p1_OR_p2 parser as follows: function OR_parser<T,R>(p1: Parser<T>, p2: Parser<R>): Parser<T|R> { return function(sinput: string): ParserResult<T|R> { const {maybe_result:v1, remaining:r1} = p1(sinput) if(Maybe.isNothing(v1)) { const {maybe_result:v2, remaining:r2} = p2(sinput) if(Maybe.isNothing(v2)) return makeParserResult(Maybe.nothing<T|R>(), r2) else { const vv = Maybe.getValue(v2) return makeParserResult(Maybe.just<T|R>(vv), r2) } } const tvalue = Maybe.getValue(v1) return makeParserResult(Maybe.just<T|R>(tvalue), r1) } }","title":"Alternatives or - the OR parser"},{"location":"03_combining_parsers/#the-followed-by-parser","text":"Lets make a function that will parser variable names. Variable names: must start with an upper or lower case letter or an underscore _ thereafter there may be zero of more characters that are either digits, uppercase letters, lowercase letters or underscores. Its pretty clear that we can do this by first parsing the initial character with function isValidFirstChar(s: string): boolean {return (s.substring(0, 1).match(/[a-zA-Z_]/g) !== null)} function isValidSubsequentChar(s: string): boolean {return (s.substring(0, 1).match(/[a-zA-Z0-9_]/g) !== null)} const firstCharParser = createPredicateParser(isValidFirstChar) and then parsing all of the remaining characters with: const subsequentCharsParser = create_OneOrMoreParser(createPredicateParser(isValidSubsequentChar)) So now lets turn our attention to creating a function that combines firstCharParser and sunsequentCharParser as described above. function parseVariableName(sinput: string): ParserResult<string> { const {maybe_result:v1, remaining:r1} = firstCharParser(sinput) if(Maybe.isNothing(v1)) { return makeParserResult(Maybe.nothing(), r1) } const first_char = Maybe.getValue(v1) const {maybe_result: v2, remaining:r2} = subsequentCharsParser(r1) if(Maybe.isNothing(v2)) { return makeParserResult(Maybe.nothing(), sinput) } const subsequent_chars = Maybe.getValue(v2) return makeParserResult(Maybe.just(first_char + subsequent_chars), r2) } Again this can be generalized as: function followedBy<T, U>(p1: Parser<T>, p2: Parser<U>): Parser<[T,U]> { return function(sinput: string) { const {maybe_result: v1, remaining: r1} = p1(sinput) if(Maybe.isNothing(v1)) { return makeParserResult(Maybe.nothing(), r1) } const t1 = Maybe.getValue(v1) const {maybe_result: v2, remaining: r2} = p2(r1) if(Maybe.isNothing(v2)) { return makeParserResult(Maybe.nothing(), sinput) } const u1 = Maybe.getValue(v2) return makeParserResult(Maybe.just([t1, u1]), r2) } } Remembering that Parser<T> = (sinput: string) => Maybe<PP<T>> we can generalize followedBy from a binary operation to an array operation. Such that a list of parsers can be applied one after the other. /** * You might recognize this as a left_fold operation */ // function sequence<T>(ps: Array<Parser<T>>): Parser<T> { // let p_accum = ps[0] // ps.slice(1).forEach((pnext) => { // p_accum = followedBy(p_accum, pnext) // }) // return p_accum // }","title":"The Followed-By Parser"},{"location":"04_ast/","text":"Abstract Syntax Tree The goal is to parse an arithmetic expression and produce a structire called an Abstract Syntax Tree . Ideally we would define the tree in a manner that parallels the BNF definition of an expression. In Haskell Something like: data TreeNode a = PlusNode TreeNode TreeNode | MultNode TreeNode TreeNode | BracketNode TreeNode | NumberNode string In Typescript something like the code below is the best we can do. abstract class TreeNode {....} class PlusNode extends TreeNode {left: TreeNode; right: TreeNode} class MultNode extends TreeNode {left: TreeNode; right: TreeNode} class BracketNode extends TreeNode {inside: TreeNode} class NumberNode extends TreeNode {value: number} However we are going to provide an implementation that follows the spirit of the above code but puts in place features that are aimed at ensuring that we cannot build an invalid binary tree. In particular our implementation will hide the class constructor and provide the following constructors function. PlusNode.make(left: TreeNode, right: TreeNode) MultNode.make(left: TreeNode, right: TreeNode) BracketNode.make(child: TreeNode) NumberNode.make(n: number) each of these make functions return a frozen object to ensure immutability. When manipulating TreeNodes one often needs to know the concrete type of a TreeNode . To facilitate this there are a set of free functions with names like isMultNode(node: TreeNode): boolean which can be used in an if-ifelse-else chain. Once having determined the concrete type of a TreeNode such a node needs to be \"cast\" to the appropriate concrete type. There are a suite of functions to do this, with error checking. Names like asMultNode(node: TreeNode): MultNode . The above arrangement provides an equivalent to the Haskell data statement provided earlier. However because of the type casting type safety depends on hand coded runtime checking. Unfortunately this is as close as I can get in Typescript to Haskells pattern matching.","title":"Ast"},{"location":"04_ast/#abstract-syntax-tree","text":"The goal is to parse an arithmetic expression and produce a structire called an Abstract Syntax Tree . Ideally we would define the tree in a manner that parallels the BNF definition of an expression. In Haskell Something like: data TreeNode a = PlusNode TreeNode TreeNode | MultNode TreeNode TreeNode | BracketNode TreeNode | NumberNode string In Typescript something like the code below is the best we can do. abstract class TreeNode {....} class PlusNode extends TreeNode {left: TreeNode; right: TreeNode} class MultNode extends TreeNode {left: TreeNode; right: TreeNode} class BracketNode extends TreeNode {inside: TreeNode} class NumberNode extends TreeNode {value: number} However we are going to provide an implementation that follows the spirit of the above code but puts in place features that are aimed at ensuring that we cannot build an invalid binary tree. In particular our implementation will hide the class constructor and provide the following constructors function. PlusNode.make(left: TreeNode, right: TreeNode) MultNode.make(left: TreeNode, right: TreeNode) BracketNode.make(child: TreeNode) NumberNode.make(n: number) each of these make functions return a frozen object to ensure immutability. When manipulating TreeNodes one often needs to know the concrete type of a TreeNode . To facilitate this there are a set of free functions with names like isMultNode(node: TreeNode): boolean which can be used in an if-ifelse-else chain. Once having determined the concrete type of a TreeNode such a node needs to be \"cast\" to the appropriate concrete type. There are a suite of functions to do this, with error checking. Names like asMultNode(node: TreeNode): MultNode . The above arrangement provides an equivalent to the Haskell data statement provided earlier. However because of the type casting type safety depends on hand coded runtime checking. Unfortunately this is as close as I can get in Typescript to Haskells pattern matching.","title":"Abstract Syntax Tree"},{"location":"applicative/","text":"\u2145 &CC; \ud835\udd39 \u212c \u0393 A\u2297Y","title":"Applicative"},{"location":"do_notation/","text":"1.0 do notation - what problem does it solve What problem does the Haskell do solve. Consider you have two functions f :: X -> M A and g :: Y -> M B which do some calculation that prepares input for a final \"bring it all together\" calculation represented by a function k :: (A, B) -> M C . As you can see all of these functions produce a Monadic result, maybe each calculation required some IO and M A may have failed so M A may equal IO Maybe A . But for the moment lets assume that M = Maybe (no IO). How would we apply k to the outcomes of f and g . In a typical imperative language we would write something like this: function combine(ma: M A, mb: M B, k: (A, B) -> M C): M C { if(ma.isNothing() || mb.isNothing()) { return Maybe.nothing() } const a = ma.get_value() const b = mb.get_value() return k(a, b) } The problem with the above solution is that it is Maybe specific. Is there a way of doing this for a general Monad ? The Haskell solution is combine :: (m a, m b, (a,b) -> m c) -> m c combine ma mb k = ma >>= (\\x -> mb >>= (\\y -> f x y)) or using do notation combine :: (m a, m b, (a,b) -> m c) -> m c combine ma mb k = do { x <- ma; y <- mb; k a b } For those like me that find the haskell hard to read the typescript version is function combine(ma: M<A>, mb: M<B>, k: (A, B) -> M<C>): M<C> { M.bind(ma, (a) => M.bind(mb, (b) => k(a,b))) } The nested function definitions (a) => M.bind(mb, (b) => k(a,b)) use scope to make the a and b available to the inner call to k(a, b) . Inline function definitions seem central to this construct. This is tested and demonstrated in file tests/test_do.ts . It should be noted that the above result can be rephrased as follows: Proposition 1: A function k: (A, B) -> M C can be extended to a function kprime: (M A, M B) -> M C . Proof: The calculation above is the proof. A more \"categorical\" approach So the above calculations seem to work but for me they are a computer scientists solution not a category theorists solution. Is there a \"higher level\" way of achieving the same end that operates at the level of \"arrows\" rather than nitty-gritty calculations. The answer of course is YES . In fact a little more is possible. Proposition 2: If M is a monad and p: A x B -> M C is a function then p can be extended to a function M A x M B -> M C An alternate proof: The following is a sequence of deductions/constructions. Each entry is derived from the preceeding entry with the justification being given in the second column. Id Function Reason the function can be deduced from the previous function 1. p: A x B -> M C The given or starting function 2. A -> [B, M C] The closed category isomorphism or currying of p 3. A -> [M B, M C] By applying the Kliesli or Monad extension theorem on the right side 4. A x M B -> M C The closed category isomorphism or reverse currying 5. M B x A -> M C Commutativity (up to isomorphism) of cartesian product 6. M B -> [A, M C] By currying 7. M B -> [M A, M C] By apply the Kliesli or Monad extension theorem 8. M B x M A -> M C By un currying 9. M A x M B -> M C commutativity (up to isomorphism) of cartesian product Now lets take some of these functions and deduce the formular for them. Equation 2. A -> [B, M C] is defined by \\a -> (\\b -> p(a, b)) Equation 3 A -> [M B, M C] is defined by \\a -> Kliesli(\\b -> p(a, b)) . Observe that Kliesli(\\b -> p(a, b)) is a function M B -> M C Equation 4. A x M B -> M C is defined by \\(a, mb) -> Kliesli(\\b -> p(a, b))(mb) or equivalently \\(a, mb) -> mb >>= (\\b -> p(a, b)) Equation 6. M B -> [A, M C] is defined by \\mb -> \\a -> Kliesli(\\b -> p(a, b))(mb) or equivalently \\mb -> (\\a -> mb >>= (\\b -> p(a, b)) ) Equation 7. M B -> [M A, M C] is defined by \\mb -> Kliesli(\\a -> Kliesli(\\b -> p(a, b))(mb) ) observe that Kliesli(\\a -> Kliesli(\\b -> p(a, b))(mb) ) is a function M A -> M C Equation 8. M B x M A -> M C is defined by \\(mb, ma) -> Kliesli(\\a -> Kliesli(\\b -> p(a, b))(mb) )(ma) or equivalently \\(mb, ma) -> ma >>= (\\a -> mb >>= (\\b -> p(a, b))) Finally by reordering the argument (mb, ma) to (ma, mb) we get: Equation 9. MA x M B -> M C defined as \\(ma, mb) -> Kliesli(\\a -> Kliesli(\\b -> p(a, b))(mb) )(ma) or equivalently \\(ma, mb) -> ma >>= (\\a -> mb >>= (\\b -> p(a, b))) Definition 1 We call the function defined in Equation 9 above Kliesli(p) In light of the above result we can now state that a Functor equipped with a Monadic structure is necessarily equipped with an Applicative structure. Proposition 3: If p: A x B -> C is a function and M is a monad then p can be lifted to a function liftA2(p) :M A x M B -> M C making M an Applicative Functor Proof: Consider the composition eta . p : A x B ---> C ---> M C . Now apply Kliesli to get Kliesli(eta . p): M A x M B -> M C . liftA2(p) = KLiesli(eta . p)","title":"Do notation"},{"location":"do_notation/#10-do-notation-what-problem-does-it-solve","text":"What problem does the Haskell do solve. Consider you have two functions f :: X -> M A and g :: Y -> M B which do some calculation that prepares input for a final \"bring it all together\" calculation represented by a function k :: (A, B) -> M C . As you can see all of these functions produce a Monadic result, maybe each calculation required some IO and M A may have failed so M A may equal IO Maybe A . But for the moment lets assume that M = Maybe (no IO). How would we apply k to the outcomes of f and g . In a typical imperative language we would write something like this: function combine(ma: M A, mb: M B, k: (A, B) -> M C): M C { if(ma.isNothing() || mb.isNothing()) { return Maybe.nothing() } const a = ma.get_value() const b = mb.get_value() return k(a, b) } The problem with the above solution is that it is Maybe specific. Is there a way of doing this for a general Monad ? The Haskell solution is combine :: (m a, m b, (a,b) -> m c) -> m c combine ma mb k = ma >>= (\\x -> mb >>= (\\y -> f x y)) or using do notation combine :: (m a, m b, (a,b) -> m c) -> m c combine ma mb k = do { x <- ma; y <- mb; k a b } For those like me that find the haskell hard to read the typescript version is function combine(ma: M<A>, mb: M<B>, k: (A, B) -> M<C>): M<C> { M.bind(ma, (a) => M.bind(mb, (b) => k(a,b))) } The nested function definitions (a) => M.bind(mb, (b) => k(a,b)) use scope to make the a and b available to the inner call to k(a, b) . Inline function definitions seem central to this construct. This is tested and demonstrated in file tests/test_do.ts . It should be noted that the above result can be rephrased as follows:","title":"1.0 do notation - what problem does it solve"},{"location":"do_notation/#proposition-1","text":"A function k: (A, B) -> M C can be extended to a function kprime: (M A, M B) -> M C . Proof: The calculation above is the proof.","title":"Proposition 1:"},{"location":"do_notation/#a-more-categorical-approach","text":"So the above calculations seem to work but for me they are a computer scientists solution not a category theorists solution. Is there a \"higher level\" way of achieving the same end that operates at the level of \"arrows\" rather than nitty-gritty calculations. The answer of course is YES . In fact a little more is possible.","title":"A more \"categorical\" approach"},{"location":"do_notation/#proposition-2","text":"If M is a monad and p: A x B -> M C is a function then p can be extended to a function M A x M B -> M C An alternate proof: The following is a sequence of deductions/constructions. Each entry is derived from the preceeding entry with the justification being given in the second column. Id Function Reason the function can be deduced from the previous function 1. p: A x B -> M C The given or starting function 2. A -> [B, M C] The closed category isomorphism or currying of p 3. A -> [M B, M C] By applying the Kliesli or Monad extension theorem on the right side 4. A x M B -> M C The closed category isomorphism or reverse currying 5. M B x A -> M C Commutativity (up to isomorphism) of cartesian product 6. M B -> [A, M C] By currying 7. M B -> [M A, M C] By apply the Kliesli or Monad extension theorem 8. M B x M A -> M C By un currying 9. M A x M B -> M C commutativity (up to isomorphism) of cartesian product Now lets take some of these functions and deduce the formular for them. Equation 2. A -> [B, M C] is defined by \\a -> (\\b -> p(a, b)) Equation 3 A -> [M B, M C] is defined by \\a -> Kliesli(\\b -> p(a, b)) . Observe that Kliesli(\\b -> p(a, b)) is a function M B -> M C Equation 4. A x M B -> M C is defined by \\(a, mb) -> Kliesli(\\b -> p(a, b))(mb) or equivalently \\(a, mb) -> mb >>= (\\b -> p(a, b)) Equation 6. M B -> [A, M C] is defined by \\mb -> \\a -> Kliesli(\\b -> p(a, b))(mb) or equivalently \\mb -> (\\a -> mb >>= (\\b -> p(a, b)) ) Equation 7. M B -> [M A, M C] is defined by \\mb -> Kliesli(\\a -> Kliesli(\\b -> p(a, b))(mb) ) observe that Kliesli(\\a -> Kliesli(\\b -> p(a, b))(mb) ) is a function M A -> M C Equation 8. M B x M A -> M C is defined by \\(mb, ma) -> Kliesli(\\a -> Kliesli(\\b -> p(a, b))(mb) )(ma) or equivalently \\(mb, ma) -> ma >>= (\\a -> mb >>= (\\b -> p(a, b))) Finally by reordering the argument (mb, ma) to (ma, mb) we get: Equation 9. MA x M B -> M C defined as \\(ma, mb) -> Kliesli(\\a -> Kliesli(\\b -> p(a, b))(mb) )(ma) or equivalently \\(ma, mb) -> ma >>= (\\a -> mb >>= (\\b -> p(a, b)))","title":"Proposition 2:"},{"location":"do_notation/#definition-1","text":"We call the function defined in Equation 9 above Kliesli(p) In light of the above result we can now state that a Functor equipped with a Monadic structure is necessarily equipped with an Applicative structure.","title":"Definition 1"},{"location":"do_notation/#proposition-3","text":"If p: A x B -> C is a function and M is a monad then p can be lifted to a function liftA2(p) :M A x M B -> M C making M an Applicative Functor Proof: Consider the composition eta . p : A x B ---> C ---> M C . Now apply Kliesli to get Kliesli(eta . p): M A x M B -> M C . liftA2(p) = KLiesli(eta . p)","title":"Proposition 3:"},{"location":"expression_parser_version_1/","text":"In this section we detail the code for version one of our expression parser. This is a version that makes almost no explicit use of Functors , Applicatives and Monads . The section starts with some usual TS preliminaries, such as import statments and some type definitions import * as Tree from \"../src/tree\" import { Parser, ParserResult, makeParserResult, followedBy3, parseNumber, whitespaceIfy, createPredicateParser, } from \"../src/parsing_intro\" import {Maybe} from \"../src/maybe_v1\" type TNode = Tree.TreeNode Parse and expression expression ::= term + expression | term Below we define a parser for expression which closely parallels the BNF definition of an expression. exp ::= term + expression | term Notice there are 2 implementations of the function term_plus_expression function expression(sinput: string): ParserResult<TNode> { const s = removeLeadingWhitespace(sinput) const r = parser_or([term_plus_expression_1, term_only], s) return r } function term_plus_expression_1(sinput: string): ParserResult<TNode> { const s = removeLeadingWhitespace(sinput) const {maybe_result: r1, remaining: rem1} = term(s) if(Maybe.isNothing(r1) || (rem1.length === 0)) { return makeParserResult(Maybe.nothing(), sinput) } const v1 = Maybe.getValue(r1) const {maybe_result: r2, remaining: rem2} = parseAdditionSign(rem1) if(Maybe.isNothing(r2)) { return makeParserResult(Maybe.nothing(), sinput) } const v2: string = Maybe.getValue(r2) let {maybe_result: r3, remaining: rem3} = expression(rem2) if(Maybe.isNothing(r3)) { return makeParserResult(Maybe.nothing(), sinput) } const v3 = Maybe.getValue(r3) if(v1 === null || v3 === null) { throw Error(\"\") ///@todo - fix this } let newast = Tree.AddNode.make(v1, v3) return makeParserResult(Maybe.just(newast), rem3) } function term_plus_expression_2(sinput: string): ParserResult<TNode> { function add(left: TNode, op: string, right: TNode): TNode { let newast = Tree.AddNode.make(left, right) return newast } return followedBy3(term, parseAdditionSign, expression, add)(sinput) } function term_only(sinput: string): ParserResult<TNode> { const s = removeLeadingWhitespace(sinput) const {maybe_result: r, remaining: rem} = term(s) if(Maybe.isNothing(r)) { return makeParserResult(Maybe.nothing(), sinput) } const v = Maybe.getValue(r) return makeParserResult(Maybe.just(v), rem) } term ::= factor * term | factor Again notice that there are 2 implementations of `factor_times_term function term(sinput: string): ParserResult<TNode> { const rr = parser_or([factor_times_term_1, factor_only], sinput) return rr } function factor_times_term_1(sinput: string): ParserResult<TNode> { const s = removeLeadingWhitespace(sinput) let {maybe_result: r1, remaining: rem1} = factor(s) if(Maybe.isNothing(r1)) { return makeParserResult(Maybe.nothing(), sinput) } const {maybe_result: r2, remaining: rem2} = parseMultiplySign(rem1) if(Maybe.isNothing(r2)) { return makeParserResult(Maybe.nothing(), sinput) } let {maybe_result: r3, remaining: rem3} = term(rem2) if(Maybe.isNothing(r3)) { return makeParserResult(Maybe.nothing(), sinput) } let left = Maybe.getValue(r1) let right = Maybe.getValue(r3) let newnode = Tree.MultNode.make(left, right) return makeParserResult(Maybe.just(newnode), rem3) } function factor_times_term_2(sinput: string): ParserResult<TNode> { function f(left: TNode, op: string, right: TNode): TNode { let newnode = Tree.MultNode.make(left, right) return newnode } const rr = followedBy3(factor, parseMultiplySign, term, f)(sinput) return rr } function factor_only(sinput: string): ParserResult<TNode> { const s = removeLeadingWhitespace(sinput) let {maybe_result: r, remaining: rem} = factor(s) if(Maybe.isNothing(r)) { return makeParserResult(Maybe.nothing(), sinput) } return makeParserResult(r, rem) } factor ::= number | (expression) function factor(sinput: string): ParserResult<TNode> { const s = removeLeadingWhitespace(sinput) return parser_or([parseNumberExp, parseBracketExp], s) } function parseBracketExp(sinput: string): ParserResult<TNode> { const s = removeLeadingWhitespace(sinput) const {maybe_result: r1, remaining: rem1} = parseOpenBracket(s) if(Maybe.isNothing(r1)) { return makeParserResult(Maybe.nothing(), sinput) } const {maybe_result: r2, remaining: rem2} = expression(rem1) if(Maybe.isNothing(r2)) { return makeParserResult(Maybe.nothing(), sinput) } const {maybe_result: r3, remaining: rem3} = parseCloseBracket(rem2) if(Maybe.isNothing(r3)) { return makeParserResult(Maybe.nothing(), sinput) } const n = Maybe.getValue(r2) const rnode = Tree.BracketNode.make(n) return makeParserResult(Maybe.just(rnode), rem3) } function parseNumberExp(sinput: string) : ParserResult<TNode> { const s = removeLeadingWhitespace(sinput) const {maybe_result: r1, remaining: rem1} = parseNumber(s) if(Maybe.isNothing(r1)) { return makeParserResult(Maybe.nothing(), sinput) } const node = Tree.NumberNode.make(parseInt(Maybe.getValue(r1))) return makeParserResult(Maybe.just(node), rem1) } Primitive Parsers const parseAdditionSign = whitespaceIfy(createPredicateParser((s) => (s === \"+\"))) const parseMultiplySign = whitespaceIfy(createPredicateParser((s) => (s === \"*\"))) const parseOpenBracket = whitespaceIfy(createPredicateParser((s) => (s === \"(\"))) const parseCloseBracket = whitespaceIfy(createPredicateParser((s) => (s === \")\"))) function removeLeadingWhitespace(s: string): string { if((s.length > 0) && (s.substring(0, 1) == \" \")) { return removeLeadingWhitespace(s.slice(1)) } return s.slice(0) } More ways of combining parsers*/ /** * Alternative - try each parser in order, on the original input, and return the result of the first that succeeds */ function parser_or(ps: Array<Parser<TNode>>, input: string): ParserResult<TNode> { if(ps.length == 0) { return makeParserResult(Maybe.nothing(), input) } const {maybe_result: r1, remaining: rem1} = ps[0](input) if(Maybe.isNothing(r1)) { return parser_or(ps.slice(1), input) } return makeParserResult(Maybe.just(Maybe.getValue(r1)), rem1) }","title":"Expression parser version 1"},{"location":"expression_parser_version_1/#parse-and-expression","text":"","title":"Parse and expression"},{"location":"expression_parser_version_1/#expression-term-expression-term","text":"Below we define a parser for expression which closely parallels the BNF definition of an expression. exp ::= term + expression | term Notice there are 2 implementations of the function term_plus_expression function expression(sinput: string): ParserResult<TNode> { const s = removeLeadingWhitespace(sinput) const r = parser_or([term_plus_expression_1, term_only], s) return r } function term_plus_expression_1(sinput: string): ParserResult<TNode> { const s = removeLeadingWhitespace(sinput) const {maybe_result: r1, remaining: rem1} = term(s) if(Maybe.isNothing(r1) || (rem1.length === 0)) { return makeParserResult(Maybe.nothing(), sinput) } const v1 = Maybe.getValue(r1) const {maybe_result: r2, remaining: rem2} = parseAdditionSign(rem1) if(Maybe.isNothing(r2)) { return makeParserResult(Maybe.nothing(), sinput) } const v2: string = Maybe.getValue(r2) let {maybe_result: r3, remaining: rem3} = expression(rem2) if(Maybe.isNothing(r3)) { return makeParserResult(Maybe.nothing(), sinput) } const v3 = Maybe.getValue(r3) if(v1 === null || v3 === null) { throw Error(\"\") ///@todo - fix this } let newast = Tree.AddNode.make(v1, v3) return makeParserResult(Maybe.just(newast), rem3) } function term_plus_expression_2(sinput: string): ParserResult<TNode> { function add(left: TNode, op: string, right: TNode): TNode { let newast = Tree.AddNode.make(left, right) return newast } return followedBy3(term, parseAdditionSign, expression, add)(sinput) } function term_only(sinput: string): ParserResult<TNode> { const s = removeLeadingWhitespace(sinput) const {maybe_result: r, remaining: rem} = term(s) if(Maybe.isNothing(r)) { return makeParserResult(Maybe.nothing(), sinput) } const v = Maybe.getValue(r) return makeParserResult(Maybe.just(v), rem) }","title":"expression ::= term + expression | term"},{"location":"expression_parser_version_1/#term-factor-term-factor","text":"Again notice that there are 2 implementations of `factor_times_term function term(sinput: string): ParserResult<TNode> { const rr = parser_or([factor_times_term_1, factor_only], sinput) return rr } function factor_times_term_1(sinput: string): ParserResult<TNode> { const s = removeLeadingWhitespace(sinput) let {maybe_result: r1, remaining: rem1} = factor(s) if(Maybe.isNothing(r1)) { return makeParserResult(Maybe.nothing(), sinput) } const {maybe_result: r2, remaining: rem2} = parseMultiplySign(rem1) if(Maybe.isNothing(r2)) { return makeParserResult(Maybe.nothing(), sinput) } let {maybe_result: r3, remaining: rem3} = term(rem2) if(Maybe.isNothing(r3)) { return makeParserResult(Maybe.nothing(), sinput) } let left = Maybe.getValue(r1) let right = Maybe.getValue(r3) let newnode = Tree.MultNode.make(left, right) return makeParserResult(Maybe.just(newnode), rem3) } function factor_times_term_2(sinput: string): ParserResult<TNode> { function f(left: TNode, op: string, right: TNode): TNode { let newnode = Tree.MultNode.make(left, right) return newnode } const rr = followedBy3(factor, parseMultiplySign, term, f)(sinput) return rr } function factor_only(sinput: string): ParserResult<TNode> { const s = removeLeadingWhitespace(sinput) let {maybe_result: r, remaining: rem} = factor(s) if(Maybe.isNothing(r)) { return makeParserResult(Maybe.nothing(), sinput) } return makeParserResult(r, rem) }","title":"term ::= factor * term | factor"},{"location":"expression_parser_version_1/#factor-number-expression","text":"function factor(sinput: string): ParserResult<TNode> { const s = removeLeadingWhitespace(sinput) return parser_or([parseNumberExp, parseBracketExp], s) } function parseBracketExp(sinput: string): ParserResult<TNode> { const s = removeLeadingWhitespace(sinput) const {maybe_result: r1, remaining: rem1} = parseOpenBracket(s) if(Maybe.isNothing(r1)) { return makeParserResult(Maybe.nothing(), sinput) } const {maybe_result: r2, remaining: rem2} = expression(rem1) if(Maybe.isNothing(r2)) { return makeParserResult(Maybe.nothing(), sinput) } const {maybe_result: r3, remaining: rem3} = parseCloseBracket(rem2) if(Maybe.isNothing(r3)) { return makeParserResult(Maybe.nothing(), sinput) } const n = Maybe.getValue(r2) const rnode = Tree.BracketNode.make(n) return makeParserResult(Maybe.just(rnode), rem3) } function parseNumberExp(sinput: string) : ParserResult<TNode> { const s = removeLeadingWhitespace(sinput) const {maybe_result: r1, remaining: rem1} = parseNumber(s) if(Maybe.isNothing(r1)) { return makeParserResult(Maybe.nothing(), sinput) } const node = Tree.NumberNode.make(parseInt(Maybe.getValue(r1))) return makeParserResult(Maybe.just(node), rem1) }","title":"factor ::= number | (expression)"},{"location":"expression_parser_version_1/#primitive-parsers","text":"const parseAdditionSign = whitespaceIfy(createPredicateParser((s) => (s === \"+\"))) const parseMultiplySign = whitespaceIfy(createPredicateParser((s) => (s === \"*\"))) const parseOpenBracket = whitespaceIfy(createPredicateParser((s) => (s === \"(\"))) const parseCloseBracket = whitespaceIfy(createPredicateParser((s) => (s === \")\"))) function removeLeadingWhitespace(s: string): string { if((s.length > 0) && (s.substring(0, 1) == \" \")) { return removeLeadingWhitespace(s.slice(1)) } return s.slice(0) }","title":"Primitive Parsers"},{"location":"expression_parser_version_1/#more-ways-of-combining-parsers","text":"/** * Alternative - try each parser in order, on the original input, and return the result of the first that succeeds */ function parser_or(ps: Array<Parser<TNode>>, input: string): ParserResult<TNode> { if(ps.length == 0) { return makeParserResult(Maybe.nothing(), input) } const {maybe_result: r1, remaining: rem1} = ps[0](input) if(Maybe.isNothing(r1)) { return parser_or(ps.slice(1), input) } return makeParserResult(Maybe.just(Maybe.getValue(r1)), rem1) }","title":"More ways of combining parsers*/"},{"location":"functor/","text":"Functor Informally In this section we are going to discuss the concept of a Functor . In Functional Programming Functors are type constructors which take a type (say) T and make it into a new type which is often represented by the notation F<T> or F T . So far this looks like a generic type of one variable. However there are additional requirements. In addition to the type constructor a Functor is required to have an associated function called fmap with the following signature: fmap: ((a: A) => B) => (a: F<A>)=>F<B> In addition fmap must take the identity function identity: A => A to the identity function identity: F<A> => F<A> preserve composition. So if f: A=>B and g:B => C then fmap(g . f) = fmap(g) . fmap(f) where . is the operation of function composition. Because a Functor takes a type as input and returns a type it is informally a type of function from Types => Types . A category Theorist would call it an endo functor on the categoru Hask . Representation in Typescript as a Class It is difficult to represent a Functor in Typescript in a way where the language enforces all of the requireed element. Ideally we would do something like this: abstract class Functor<T> { abstract static fmap(f:(a:A) => B): (a: F<A>) => F<B>; } but TS does not permit abstract static methods . Nor can we make this an interface as interfaces don't sufficietly support statis methods. So I am going to settle for something informal. Functor definition A functor is a pair (F, fmap) where : a F is a generic class with one type parameter and fmap is a static method of the class F where F.fmap:((a:A) => B): (a: F<A>)=>F<B> where F.fmap satisfies the identity and composition rules described above thus we often write the minimum requirement of a functor in pseudo TS as: class F<T> { public static fmap<A,B>(f:(a:A)=>B):(a:F<A> => F<B>) { ...... } } Of course this is not complete class definition as it requires possible properties and definitely a constructor. For an example see the definition of Maybe.fmap in the file Maybe_v2.ts class Functor<T>{ fmap<A,B>(f:(a:A) => B): ((x:F<A>)=>F<B>) {} } Representation in Typescript as a Module The idea here is that a function will be inplemented in a module, which in TS means a separate file with some export statments. For a functor the module should export a generic type, some contructor functions and other utility functions, and an fmap function. Consider the following definition of the Maybe functor as a module. export type Type<T> = T | null export function nothing<T>(): Type<T> {return null} export function just<T>(t:T): Type<T> {return t} export function isNothing<T>(x: Type<T>): boolean {return x === null} export function getValue(x: Type<T>): T { if(x === null) { throw new Error(`trying to get value of nothing`) } else { return x } } export function fmap<A,B>(f: (a:A) => B): (x:Type<A>) => Type<B> { return function(x: Type<A>): Type<B> { if(isNothing(x)) return nothing() else return just(f(getValue(x))) } } By convention we will have all modules that are functors export their single generic type with the name Type The user of this Maybe module would use code as follows: import * as Maybe from './maybe` const v: Maybe.Type<string> = Maybe.just(\"this is a string\") if(Maybe.ifNothing(v)) { // do something } else { const internal_value = Maybe.getValue(v) .... do something with internal_value } In the first attempt at a parser for arithmetic expressions we used the class based definition of Maybe as that seemed more in keeping with TS from a stylistic point of view. However going forward we are going to use the module approach as it is very similar to the way OCAML , Rescript and ReasonML package Functors and Monads. Unfortunately TS does not have all the features of those languages so there will still be some rough spots.","title":"Functor"},{"location":"functor/#functor","text":"","title":"Functor"},{"location":"functor/#informally","text":"In this section we are going to discuss the concept of a Functor . In Functional Programming Functors are type constructors which take a type (say) T and make it into a new type which is often represented by the notation F<T> or F T . So far this looks like a generic type of one variable. However there are additional requirements. In addition to the type constructor a Functor is required to have an associated function called fmap with the following signature: fmap: ((a: A) => B) => (a: F<A>)=>F<B> In addition fmap must take the identity function identity: A => A to the identity function identity: F<A> => F<A> preserve composition. So if f: A=>B and g:B => C then fmap(g . f) = fmap(g) . fmap(f) where . is the operation of function composition. Because a Functor takes a type as input and returns a type it is informally a type of function from Types => Types . A category Theorist would call it an endo functor on the categoru Hask .","title":"Informally"},{"location":"functor/#representation-in-typescript-as-a-class","text":"It is difficult to represent a Functor in Typescript in a way where the language enforces all of the requireed element. Ideally we would do something like this: abstract class Functor<T> { abstract static fmap(f:(a:A) => B): (a: F<A>) => F<B>; } but TS does not permit abstract static methods . Nor can we make this an interface as interfaces don't sufficietly support statis methods. So I am going to settle for something informal.","title":"Representation in Typescript as a Class"},{"location":"functor/#functor-definition","text":"A functor is a pair (F, fmap) where : a F is a generic class with one type parameter and fmap is a static method of the class F where F.fmap:((a:A) => B): (a: F<A>)=>F<B> where F.fmap satisfies the identity and composition rules described above thus we often write the minimum requirement of a functor in pseudo TS as: class F<T> { public static fmap<A,B>(f:(a:A)=>B):(a:F<A> => F<B>) { ...... } } Of course this is not complete class definition as it requires possible properties and definitely a constructor. For an example see the definition of Maybe.fmap in the file Maybe_v2.ts class Functor<T>{ fmap<A,B>(f:(a:A) => B): ((x:F<A>)=>F<B>) {} }","title":"Functor definition"},{"location":"functor/#representation-in-typescript-as-a-module","text":"The idea here is that a function will be inplemented in a module, which in TS means a separate file with some export statments. For a functor the module should export a generic type, some contructor functions and other utility functions, and an fmap function. Consider the following definition of the Maybe functor as a module. export type Type<T> = T | null export function nothing<T>(): Type<T> {return null} export function just<T>(t:T): Type<T> {return t} export function isNothing<T>(x: Type<T>): boolean {return x === null} export function getValue(x: Type<T>): T { if(x === null) { throw new Error(`trying to get value of nothing`) } else { return x } } export function fmap<A,B>(f: (a:A) => B): (x:Type<A>) => Type<B> { return function(x: Type<A>): Type<B> { if(isNothing(x)) return nothing() else return just(f(getValue(x))) } } By convention we will have all modules that are functors export their single generic type with the name Type The user of this Maybe module would use code as follows: import * as Maybe from './maybe` const v: Maybe.Type<string> = Maybe.just(\"this is a string\") if(Maybe.ifNothing(v)) { // do something } else { const internal_value = Maybe.getValue(v) .... do something with internal_value } In the first attempt at a parser for arithmetic expressions we used the class based definition of Maybe as that seemed more in keeping with TS from a stylistic point of view. However going forward we are going to use the module approach as it is very similar to the way OCAML , Rescript and ReasonML package Functors and Monads. Unfortunately TS does not have all the features of those languages so there will still be some rough spots.","title":"Representation in Typescript as a Module"},{"location":"hask/","text":"The Hask Category All the category theory concepts used in Haskell take place in the Hask category where objects are Haskell types and arrows between two types are Haskel function between those 2 types. We will use the notation Hom(A, B) to be the set of all arrows between A and B . Cartesian Closed Categories Hask in what a category theorist would call a Cartesian Closed Category . This means the category has a products operation between object for every two objects A and B in Hask there is another object called A x B which has certain universal proterties. the is a special object, the initial object, called I such that I x A \u2245 A x I \u2245 A the category has internal Hom for every two objects A and B there is an object in the category called [A, B] such that and the following special relationship between these two operations [I, B] \u2245 B [A x B, C] \u2245 [A, [B, C]] Hom(A x B, C) \u2245 Hom(A, [B, C]) ... the Curry Isomorphism . Caveat - are types a single thing or a set of all the possible values a type can take ? For all of this to work one must squint when looking at Hask by sometimes seeing a type as a single thing and sometimes interpretting a type as the set of all possible values. Thus somethimes [A, B] is considered as the same as Hom(A, B) . This is unsatisfactory. Currying Notice that the 3rd of the above relationships is the identity that permits currying of functions. Monoidal Category A monoidal category is a category that has a binary operation between objects that is not necessarily a product . For such ccategories the x operator is replaced by a binary operator called \u2297 and does not have the universal properties of a product. Adjunction The relationships above (curry isomorphism) says that the two functors _ x B : Hask -> Hask and [B, _] : Hask -> Hask are adjoint with _ x B being left adjoint to [B, ] Unit and counit of the adjuction Take id: A x B -> A x B and apply the curry relationship to get unit: A -> [B, A x B] Similarly take id: [A, B] -> [A, B] and apply reverse currying to get counit: [A, B] x A -> B The unit function is defined as unit(a): B -> A x B such that unit(a)(b) = (a,b) The counit function is defined by counit(f, a) = f(a) . It could be called eval The curry isomporphism can be defined in terms of the unit and counit . If f: A x B -> C then its curried equivalent is the composition unit: A -> [B, A x B] followed by [B, f]: [B, A x B] -> [B, C] . Conversely g: A -> [B, C] then its reverse curry equivalent is the composition g x B: A x B -> [[B, C] x B] followed by counit: [[B, C] x B] -> C Functors between Monoidal (Or even Cartesian) Closed Categories Let F be a functor from Hask to Hask . What is the relationship between: F(A) x F(B) and F(A x B) F([A, B]) and [F(A), F(B)] In general the answer is __ there is no relationship__. But there are two special cases. Functor - Lax Monoidal The functor F is lax monoidal if 1. for all A and B there exists a function nu(A,B) :F(A) x F(B) -> F(A x B) 2. for all A there exists a function iotaA: I -> F(I) which are natural in A, B , I and satisfying a bunch of coherence rules. Functor - Lax Closed The functor F is lax closed if 1. for all A and B there exists a function zeta(A,B): F([A, B]) -> [F(A), F(B)] which is natural in A and B and satisfy some coherence conditions. Functor - In the Hask category Lax monoidal and lax closed are equivalent See https://ncatlab.org/nlab/show/closed+functor Assume F is lax monoidal. Consider nu([A, B], A): F([A, B]) x F(A) -> F([A, B] x A) and compose on the right with F(counit) to get a function: F([A, B]) x F(A) -> F(B) Now take the curried equivalent of this function to get a function F([A, B]) -> [F(A), F(B)] which is zeta(A, B) . Now assume F is lax closed. Apply F to the unit to get F(unit): F(A) -> F([B, A x B]) Now compose on the right with zeta(B, [A, B]) to get a function F(A) -> [F(B), F(A x B)] Now apply reverse currying to get F(A) x F(B) -> F(A x B) Functor - Lax monoidal = lax closed = applicative Slogans 1. Applicative Functors lift n-ary operations Let op:: A x B -> C be a binary operation. liftA2(op) = F(op) \u08aa nu(A, B) : F(A) x F(B) -> F(C) This can clearly be extended inductively to n-ary operations 2. Applicative Functors provide a lifting of curried function to curried functions Left as an exercise for the reader","title":"The Hask Category"},{"location":"hask/#the-hask-category","text":"All the category theory concepts used in Haskell take place in the Hask category where objects are Haskell types and arrows between two types are Haskel function between those 2 types. We will use the notation Hom(A, B) to be the set of all arrows between A and B .","title":"The Hask Category"},{"location":"hask/#cartesian-closed-categories","text":"Hask in what a category theorist would call a Cartesian Closed Category . This means the category has a products operation between object for every two objects A and B in Hask there is another object called A x B which has certain universal proterties. the is a special object, the initial object, called I such that I x A \u2245 A x I \u2245 A the category has internal Hom for every two objects A and B there is an object in the category called [A, B] such that and the following special relationship between these two operations [I, B] \u2245 B [A x B, C] \u2245 [A, [B, C]] Hom(A x B, C) \u2245 Hom(A, [B, C]) ... the Curry Isomorphism .","title":"Cartesian Closed Categories"},{"location":"hask/#caveat-are-types-a-single-thing-or-a-set-of-all-the-possible-values-a-type-can-take","text":"For all of this to work one must squint when looking at Hask by sometimes seeing a type as a single thing and sometimes interpretting a type as the set of all possible values. Thus somethimes [A, B] is considered as the same as Hom(A, B) . This is unsatisfactory.","title":"Caveat - are types a single thing or a set of all the possible values a type can take ?"},{"location":"hask/#currying","text":"Notice that the 3rd of the above relationships is the identity that permits currying of functions.","title":"Currying"},{"location":"hask/#monoidal-category","text":"A monoidal category is a category that has a binary operation between objects that is not necessarily a product . For such ccategories the x operator is replaced by a binary operator called \u2297 and does not have the universal properties of a product.","title":"Monoidal Category"},{"location":"hask/#adjunction","text":"The relationships above (curry isomorphism) says that the two functors _ x B : Hask -> Hask and [B, _] : Hask -> Hask are adjoint with _ x B being left adjoint to [B, ]","title":"Adjunction"},{"location":"hask/#unit-and-counit-of-the-adjuction","text":"Take id: A x B -> A x B and apply the curry relationship to get unit: A -> [B, A x B] Similarly take id: [A, B] -> [A, B] and apply reverse currying to get counit: [A, B] x A -> B The unit function is defined as unit(a): B -> A x B such that unit(a)(b) = (a,b) The counit function is defined by counit(f, a) = f(a) . It could be called eval The curry isomporphism can be defined in terms of the unit and counit . If f: A x B -> C then its curried equivalent is the composition unit: A -> [B, A x B] followed by [B, f]: [B, A x B] -> [B, C] . Conversely g: A -> [B, C] then its reverse curry equivalent is the composition g x B: A x B -> [[B, C] x B] followed by counit: [[B, C] x B] -> C","title":"Unit and counit of the adjuction"},{"location":"hask/#functors-between-monoidal-or-even-cartesian-closed-categories","text":"Let F be a functor from Hask to Hask . What is the relationship between: F(A) x F(B) and F(A x B) F([A, B]) and [F(A), F(B)] In general the answer is __ there is no relationship__. But there are two special cases.","title":"Functors between Monoidal (Or even Cartesian) Closed Categories"},{"location":"hask/#functor-lax-monoidal","text":"The functor F is lax monoidal if 1. for all A and B there exists a function nu(A,B) :F(A) x F(B) -> F(A x B) 2. for all A there exists a function iotaA: I -> F(I) which are natural in A, B , I and satisfying a bunch of coherence rules.","title":"Functor - Lax Monoidal"},{"location":"hask/#functor-lax-closed","text":"The functor F is lax closed if 1. for all A and B there exists a function zeta(A,B): F([A, B]) -> [F(A), F(B)] which is natural in A and B and satisfy some coherence conditions.","title":"Functor - Lax Closed"},{"location":"hask/#functor-in-the-hask-category-lax-monoidal-and-lax-closed-are-equivalent","text":"See https://ncatlab.org/nlab/show/closed+functor Assume F is lax monoidal. Consider nu([A, B], A): F([A, B]) x F(A) -> F([A, B] x A) and compose on the right with F(counit) to get a function: F([A, B]) x F(A) -> F(B) Now take the curried equivalent of this function to get a function F([A, B]) -> [F(A), F(B)] which is zeta(A, B) . Now assume F is lax closed. Apply F to the unit to get F(unit): F(A) -> F([B, A x B]) Now compose on the right with zeta(B, [A, B]) to get a function F(A) -> [F(B), F(A x B)] Now apply reverse currying to get F(A) x F(B) -> F(A x B)","title":"Functor - In the Hask category Lax monoidal and lax closed are equivalent"},{"location":"hask/#functor-lax-monoidal-lax-closed-applicative","text":"","title":"Functor - Lax monoidal = lax closed = applicative"},{"location":"hask/#slogans","text":"","title":"Slogans"},{"location":"hask/#1-applicative-functors-lift-n-ary-operations","text":"Let op:: A x B -> C be a binary operation. liftA2(op) = F(op) \u08aa nu(A, B) : F(A) x F(B) -> F(C) This can clearly be extended inductively to n-ary operations","title":"1. Applicative Functors lift n-ary operations"},{"location":"hask/#2-applicative-functors-provide-a-lifting-of-curried-function-to-curried-functions","text":"Left as an exercise for the reader","title":"2. Applicative Functors provide a lifting of curried function to curried functions"},{"location":"haskell/","text":"Monads and Applicatives Functor class Functor f where fmap :: (a -> b) -> f a -> f b (<$) :: a -> f b -> f a Applicative class Functor f => Applicative f where pure :: a -> m a (<*>) :: m (a->b) -> m a -> mb or liftA2 :: (a -> b -> c) -> (m a -> m b -> m c) (<*>) and liftA2 are related by the following equations: (<*>) = liftA2 id liftA2 f x y = f <$> x <*> y see Note below by RB where <$> is apply fmap and then evaluate (<$>) :: (a -> b) -> m a -> m b \\fab -> (\\ma -> fmap(fab)(ma)) Note 1 - liftA2 from <*> Regarding ```haskell liftA2 f x y = f <$> x <*> y liftA2 :: (a -> (b -> c) -> (m a -> (m b -> m c)) fmap :: (a -> (b -> c)) -> (m a -> m (b -> c)) If f :: a -> (b -> c) then fmap f :: m a -> m (b -> c) and `fmap f ma` is of type `m (b -> c)` and hence is a suitable first argument for `<*>` select a second argument `fmbc` of type `m (b -> c)` then ```haskell fmap f ma <*> fmbc is of type (m a -> m b) putting this all together liftA2 f ma fmbc = fmap f ma <*> fmbc ### NOTE 2 - <*> from liftA2 ```haskell (<*>) = liftA2 id liftA2 :: (a -> (b -> c)) -> (f a -> (f b -> f c)) lets replace a with (b -> c) liftA2 :: ((b -> c) -> (b -> c)) -> (f (b -> c) -> (f b -> f c)) now evaluate liftA2 on the identity :: (b -> c) -> (b -> c) liftA2 identity :: f (b -> c) -> (f b -> f c) as required Haskel definition of a Monad class Monad m where (>>=) :: m a -> ( a -> m b) -> m b (>>) :: m a -> m b -> m b return :: a -> m a View a Monad as an Applicative fmap fab ma = do { a <- ma ; return (fab a) } -- ma >>= (return . fab) pure a = do { return a } -- return a mfab <*> ma = do { fab <- mfab ; a <- ma ; return (fab a) } -- mfab >>= (\\ fab -> ma >>= (return . fab)) -- mfab `ap` ma Analysis of applicative definitions Let fab be a function of type a -> b . The expression return . fab is the composition fab followed by return as in a -> b -> m b Let ma be a value of type m a then we can form the value ma >>= return .fab which is a value of type m b . Call that value mb and note it depends on fab and ma . The function \\fab -> ma >>= (return . fab) is of type (a -> b) -> m b . For convenience call this function g :: (a -> b) -> m b . We take out the dependency of ma we could denote this as h: m a -> ((a -> b) -> m b) so that g is simple h evaluated at ma . For any value mfab of type m (a -> b) we can form the value mfab >>= h(ma) which is of type m b . The expression mfab >>= h(ma) is the definition of mfab <*> ma Kliesli extension The Kliesli condition is a characteristic of a monad that fully defines the monad. It states that for every f :: a -> m b there exists a unique Kliesli(f) :: m a -> m b such that f = (Kliesli(f) . return) :: a -> m am -> m b Given the Monad definition the Kliesli extension is defined as: KLiesli(f) = mu . fmap(f) :: m a -> m m b -> m b or for f::a -> m b and ma in m a Kliesli(f)(ma) = f >>= ma All function m a -> m b are KLiesli extensions Consider a map f :: m a -> m b some simple diagram chasing will demonstrate that for all ma :: (m a) kliesli(f . pure)(ma) = (\\a -> kliesli(f . pure)(ma) = f(ma) which is just another way of saying kliesli(f . pure) = f . That is the function kliesli :: (a -> m b) -> (ma -> mb) and (\\f -> f . pure) :: (m a -> m b) -> (a -> m b) constitute an isomorphism. do notation What problem does the haskell do solve. Consider you have two functions f :: X -> M A and g :: Y -> M B which do some caclulation that prepare input for a final \"bring it all together\" calculation represented by a function k :: (A, B) -> M C . As you can see all of these functions produce a Monadic result, maybe each calculation required some IO and ma have failed so M A ma equal IO Maybe A . But for the moment lets assume that M = Maybe (no IO). How would we apply k to the outcomes of f and g . In a typical imperative language we would write something like this: function combine(ma: M A, mb: M B, k: (A, B) -> M C) if(ma.isNothing() || mb.isNothing()) { return Maybe.nothing() } const a = ma.get_value() const b = mb.get_value() return k(a, b) } The problem with the above solution is that it is Maybe specific. Is there a way of doing this for a general Monad ? The haskell solution is combine :: (m a, m b, (a,b) -> m c) -> m c combine ma mb k = ma >>= (\\x -> mb >>= (\\y -> f x y)) or using do notation combine :: (m a, m b, (a,b) -> m c) -> m c combine ma mb k = do { x <- ma; y <- mb; k a b } Translating this into a hypothetical monad `M` yields (ignoring generic parameters) function combine(ma: M<A>, mb: M<B>, k: (A, B) -> M<C>) M.bind(ma, (a) => M.bind(mb, (b) => k(a,b))) } This is tested in parser_applicative.ts","title":"Haskell"},{"location":"haskell/#monads-and-applicatives","text":"","title":"Monads and Applicatives"},{"location":"haskell/#functor","text":"class Functor f where fmap :: (a -> b) -> f a -> f b (<$) :: a -> f b -> f a","title":"Functor"},{"location":"haskell/#applicative","text":"class Functor f => Applicative f where pure :: a -> m a (<*>) :: m (a->b) -> m a -> mb or liftA2 :: (a -> b -> c) -> (m a -> m b -> m c) (<*>) and liftA2 are related by the following equations: (<*>) = liftA2 id liftA2 f x y = f <$> x <*> y see Note below by RB where <$> is apply fmap and then evaluate (<$>) :: (a -> b) -> m a -> m b \\fab -> (\\ma -> fmap(fab)(ma))","title":"Applicative"},{"location":"haskell/#note-1-lifta2-from","text":"Regarding ```haskell liftA2 f x y = f <$> x <*> y liftA2 :: (a -> (b -> c) -> (m a -> (m b -> m c)) fmap :: (a -> (b -> c)) -> (m a -> m (b -> c)) If f :: a -> (b -> c) then fmap f :: m a -> m (b -> c) and `fmap f ma` is of type `m (b -> c)` and hence is a suitable first argument for `<*>` select a second argument `fmbc` of type `m (b -> c)` then ```haskell fmap f ma <*> fmbc is of type (m a -> m b) putting this all together liftA2 f ma fmbc = fmap f ma <*> fmbc ### NOTE 2 - <*> from liftA2 ```haskell (<*>) = liftA2 id liftA2 :: (a -> (b -> c)) -> (f a -> (f b -> f c)) lets replace a with (b -> c) liftA2 :: ((b -> c) -> (b -> c)) -> (f (b -> c) -> (f b -> f c)) now evaluate liftA2 on the identity :: (b -> c) -> (b -> c) liftA2 identity :: f (b -> c) -> (f b -> f c) as required","title":"Note 1 - liftA2 from &lt;*&gt;"},{"location":"haskell/#haskel-definition-of-a-monad","text":"class Monad m where (>>=) :: m a -> ( a -> m b) -> m b (>>) :: m a -> m b -> m b return :: a -> m a","title":"Haskel definition of a Monad"},{"location":"haskell/#view-a-monad-as-an-applicative","text":"fmap fab ma = do { a <- ma ; return (fab a) } -- ma >>= (return . fab) pure a = do { return a } -- return a mfab <*> ma = do { fab <- mfab ; a <- ma ; return (fab a) } -- mfab >>= (\\ fab -> ma >>= (return . fab)) -- mfab `ap` ma","title":"View a Monad as an Applicative"},{"location":"haskell/#analysis-of-applicative-definitions","text":"Let fab be a function of type a -> b . The expression return . fab is the composition fab followed by return as in a -> b -> m b Let ma be a value of type m a then we can form the value ma >>= return .fab which is a value of type m b . Call that value mb and note it depends on fab and ma . The function \\fab -> ma >>= (return . fab) is of type (a -> b) -> m b . For convenience call this function g :: (a -> b) -> m b . We take out the dependency of ma we could denote this as h: m a -> ((a -> b) -> m b) so that g is simple h evaluated at ma . For any value mfab of type m (a -> b) we can form the value mfab >>= h(ma) which is of type m b . The expression mfab >>= h(ma) is the definition of mfab <*> ma","title":"Analysis of applicative definitions"},{"location":"haskell/#kliesli-extension","text":"The Kliesli condition is a characteristic of a monad that fully defines the monad. It states that for every f :: a -> m b there exists a unique Kliesli(f) :: m a -> m b such that f = (Kliesli(f) . return) :: a -> m am -> m b Given the Monad definition the Kliesli extension is defined as: KLiesli(f) = mu . fmap(f) :: m a -> m m b -> m b or for f::a -> m b and ma in m a Kliesli(f)(ma) = f >>= ma","title":"Kliesli extension"},{"location":"haskell/#all-function-m-a-m-b-are-kliesli-extensions","text":"Consider a map f :: m a -> m b some simple diagram chasing will demonstrate that for all ma :: (m a) kliesli(f . pure)(ma) = (\\a -> kliesli(f . pure)(ma) = f(ma) which is just another way of saying kliesli(f . pure) = f . That is the function kliesli :: (a -> m b) -> (ma -> mb) and (\\f -> f . pure) :: (m a -> m b) -> (a -> m b) constitute an isomorphism.","title":"All function m a -&gt; m b are KLiesli extensions"},{"location":"haskell/#do-notation","text":"What problem does the haskell do solve. Consider you have two functions f :: X -> M A and g :: Y -> M B which do some caclulation that prepare input for a final \"bring it all together\" calculation represented by a function k :: (A, B) -> M C . As you can see all of these functions produce a Monadic result, maybe each calculation required some IO and ma have failed so M A ma equal IO Maybe A . But for the moment lets assume that M = Maybe (no IO). How would we apply k to the outcomes of f and g . In a typical imperative language we would write something like this: function combine(ma: M A, mb: M B, k: (A, B) -> M C) if(ma.isNothing() || mb.isNothing()) { return Maybe.nothing() } const a = ma.get_value() const b = mb.get_value() return k(a, b) } The problem with the above solution is that it is Maybe specific. Is there a way of doing this for a general Monad ? The haskell solution is combine :: (m a, m b, (a,b) -> m c) -> m c combine ma mb k = ma >>= (\\x -> mb >>= (\\y -> f x y)) or using do notation combine :: (m a, m b, (a,b) -> m c) -> m c combine ma mb k = do { x <- ma; y <- mb; k a b } Translating this into a hypothetical monad `M` yields (ignoring generic parameters) function combine(ma: M<A>, mb: M<B>, k: (A, B) -> M<C>) M.bind(ma, (a) => M.bind(mb, (b) => k(a,b))) } This is tested in parser_applicative.ts","title":"do notation"},{"location":"interesting_links/","text":"Interesting Links https://stackoverflow.com/questions/45712106/why-are-promises-monads https://write.yiransheng.com/callcc https://itnext.io/continuations-in-typescript-db18402010bc https://curiosity-driven.org/monads-in-javascript https://maxhallinan.com/posts/2019/10/22/how-does-the-continuation-monad-work/","title":"Interesting Links"},{"location":"interesting_links/#interesting-links","text":"https://stackoverflow.com/questions/45712106/why-are-promises-monads https://write.yiransheng.com/callcc https://itnext.io/continuations-in-typescript-db18402010bc https://curiosity-driven.org/monads-in-javascript https://maxhallinan.com/posts/2019/10/22/how-does-the-continuation-monad-work/","title":"Interesting Links"},{"location":"junk/","text":"","title":"Junk"},{"location":"maybe_v1/","text":"Maybe Monad - Version 1 I am introducing this example of a Monad early in the exposition because it will be required in the next couple of section. However a full treatment of Monads will be delayed until much later in this paper. The Haskell Maybe Monad is available in many languages under the name Optional , Nullable , or Union with null. In TS we can define a type that optionally has a value as Nullable<T> which is defined as T | null . However I chose to define a type Maybe<T> more like the definition from Haskel. For the moment I have ommitted many of the monad characteristics. THat will be covered in a future section entitled Maybe Monad V2 . export class Maybe<T> { private value: T | null private constructor(v: T|null) { this.value = v } public static just<T>(t: T): Maybe<T> { let obj: Maybe<T> = new Maybe<T>(t) return obj } public static nothing<T>(): Maybe<T> { return new Maybe<T>(null) } public static isNothing<T>(r: Maybe<T>): boolean { return (r.value === null) } public static getValue<T>(r: Maybe<T>): T { if(r.value === null) { throw Error(\"trying to be value from a nothing Maybe\") } return r.value } } The benefit of this definition is that it more closely follows the Haskel notation, and hence is an aid to understanding. Note some of the characteristics of this definition. It is not possible to make an instance of Maybe<T> that is invalid. The class constructor is private and there are only 2 constructors implemented as publis static functions. The type is opaque, the value property cannot be modified or queried except by the use of the give static function. Instances of Maybe<T> are immutable, doubly so no access to the value property and the instances are frozen.","title":"Maybe v1"},{"location":"maybe_v1/#maybe-monad-version-1","text":"I am introducing this example of a Monad early in the exposition because it will be required in the next couple of section. However a full treatment of Monads will be delayed until much later in this paper. The Haskell Maybe Monad is available in many languages under the name Optional , Nullable , or Union with null. In TS we can define a type that optionally has a value as Nullable<T> which is defined as T | null . However I chose to define a type Maybe<T> more like the definition from Haskel. For the moment I have ommitted many of the monad characteristics. THat will be covered in a future section entitled Maybe Monad V2 . export class Maybe<T> { private value: T | null private constructor(v: T|null) { this.value = v } public static just<T>(t: T): Maybe<T> { let obj: Maybe<T> = new Maybe<T>(t) return obj } public static nothing<T>(): Maybe<T> { return new Maybe<T>(null) } public static isNothing<T>(r: Maybe<T>): boolean { return (r.value === null) } public static getValue<T>(r: Maybe<T>): T { if(r.value === null) { throw Error(\"trying to be value from a nothing Maybe\") } return r.value } } The benefit of this definition is that it more closely follows the Haskel notation, and hence is an aid to understanding. Note some of the characteristics of this definition. It is not possible to make an instance of Maybe<T> that is invalid. The class constructor is private and there are only 2 constructors implemented as publis static functions. The type is opaque, the value property cannot be modified or queried except by the use of the give static function. Instances of Maybe<T> are immutable, doubly so no access to the value property and the instances are frozen.","title":"Maybe Monad - Version 1"},{"location":"maybe_v2/","text":"Maybe Monad - Version 2 This version has been expanded to contain all the Monad functions. Wraps a T value or is null - so we have Nullable . We could then do the standard TS thiing and check for null before using a Maybe value. However I wanted the Maybe Monad to be more overtly visible than that approach would have yielded. export class Maybe2<T> { value: T | null constructor() { this.value = null } static nothing<T>(): Maybe2<T> { return new Maybe2() } static just<T>(t: T): Maybe2<T> { let obj = new Maybe2<T>() obj.value = t return obj } static isNothing<T>(mb: Maybe2<T>): boolean { return (mb.value == null) } static getValue<T>(mb: Maybe2<T>): T { if(!mb.value) { throw new Error(`Maybe.getValue error is nothing `) } else { return mb.value } } static pure<T>(v: T): Maybe2<T> { let obj = Maybe2.just(v) as Maybe2<T> return obj } /* * The definition of a monad */ static eta<T>(v: T): Maybe2<T> { return Maybe2.pure(v) } static mu<T>(mmt: Maybe2<Maybe2<T>>): Maybe2<T> { if(Maybe2.isNothing(mmt) || Maybe2.isNothing(Maybe2.getValue(mmt))) { return Maybe2.nothing() } return Maybe2.getValue(Maybe2.getValue(mmt)) as unknown as Maybe2<T> } }","title":"Maybe v2"},{"location":"maybe_v2/#maybe-monad-version-2","text":"This version has been expanded to contain all the Monad functions. Wraps a T value or is null - so we have Nullable . We could then do the standard TS thiing and check for null before using a Maybe value. However I wanted the Maybe Monad to be more overtly visible than that approach would have yielded. export class Maybe2<T> { value: T | null constructor() { this.value = null } static nothing<T>(): Maybe2<T> { return new Maybe2() } static just<T>(t: T): Maybe2<T> { let obj = new Maybe2<T>() obj.value = t return obj } static isNothing<T>(mb: Maybe2<T>): boolean { return (mb.value == null) } static getValue<T>(mb: Maybe2<T>): T { if(!mb.value) { throw new Error(`Maybe.getValue error is nothing `) } else { return mb.value } } static pure<T>(v: T): Maybe2<T> { let obj = Maybe2.just(v) as Maybe2<T> return obj } /* * The definition of a monad */ static eta<T>(v: T): Maybe2<T> { return Maybe2.pure(v) } static mu<T>(mmt: Maybe2<Maybe2<T>>): Maybe2<T> { if(Maybe2.isNothing(mmt) || Maybe2.isNothing(Maybe2.getValue(mmt))) { return Maybe2.nothing() } return Maybe2.getValue(Maybe2.getValue(mmt)) as unknown as Maybe2<T> } }","title":"Maybe Monad - Version 2"},{"location":"monad/","text":"Monad A monad is: - a type constructor we will call M , that is a generic type with a single argument, - together with a set of functions (that is free functions or static methods of a class). They are: fmap(f:(a: A) => B): (ma: M<A>) => M<B> eta(a: A): M<A> often called pure or return mu(mma: M<M<A>>): M<A>) kliesli((f:(a: A) => M<B>): (ma: M<A>) => M<B> bind(ma: M<A>, f:(a: A) -> M<B>): M<B> kliesliA2: (f:(a:A, b:B) => M<C>): (ma:M<A>, mb: M<B>) => M<C> app(f:(a:A) => B, ma: M<A>): M<B> Note not all of these functions are independent, that is some can be derived from the others. Generally in this project we will require fmap , eta and either `bind or mu to be provided for each instance of a monad and the others will be derived from those. A more formal definition of a Monad A Monad is a triple (F, eta, mu) or (F, eta, bind) where: F is a functor each type A eta is a function eta(A): (a:A) => F<A> each type A mu is a function mu(A): (x:F<F<A>>) => F<A> each A bind is a function `bind(A,B): (x: F , f: (a:A) => F ) => F Notice the each of eta , mu and bind is actually a family of functions, one for each A . Sometimes in a formula we need to identify which instance of eta or mu we are talking about. The convention in CT is to provide that information as a subscript. But thats difficult to do in markdown inside of a code block. Hence, in discussions, we will pretend eta and mu are function so eta(A) : A => F<A> . The functions eta and mu must satisfy the rules: eta and mu are natural in A . I might discuss later. mu(A) . F.fmap(eta) = identity of A mu(A) . mu(F<A>) = mu(A) . fmap(mu(A)) the equiavelnt conditions on eta and bind are: eta and bind are natural in A and B . I might discuss later. bind(A)(x: F<A>, eta(A): A => F<A>) == x bind(eta(A)(a), f: A => F<B>) == f(a) bind(bind(ma, f), g) == bind(ma, ((x) => bind(f(x), g))) where g: B => F C and f: A => F B Start with the core monad elements Lets now assume we have a monad defined as a TS module. The details of the generic type Type<T> and the functions fmap , eta , and mu are left unspecified as we do not wish to use the specific details of any particular monad. type Type<T> = ... const fmap<A, B>: (f:(a: A) => B): (ma: Type<A>) => Type<B> = ... const eta<A> : (a:A) => Type<A> = .... const mu<A> :(a:Type<Type<A>>) => Type<A> = .... Now we will construct some other well known Monad functions from those beginnings. Kliesli Function The universal property of a Monad M is that forever f: A => M.Type<B> there is a unique g: M.Type<A> => M<B> sucn that g . eta(A) = f . In fact g = mu(M.Type<A>) . M.fmap(f) I like to think of the function g as the Kliesli lifting of f and to write it as kliesli(f) . The following code is inside the module representing M . Note I have elaborate with the steps and the typing to ensure understanding of what is happening. function kliesli<A,B>(f:(a: A) => Type<B>): (ma: Type<A>) => Type<B> { const r1 = fmap(f) return function(x:Type<A>): Type<B> { const fmap_f: (x: Type<A>) => Type<Type<B>> = fmap(f) const z1: Type<Type<B>> = fmap_f(x) const z2: Type<B> = mu(z1) return z2 } } The bind function in terms of the kliesli function Haskel defines the bind function as an infix operation named >>= . TS does not permit custom infix operations so we have to be content with function of two arguments. To provide motivation const ma: Type<A> const f: (a:A) => Type<B> const mb: Type<B> = (ma >>= f) is the same as kliesli(f)(ms) More formally function bind<T,S>(x: Type<T>, f: (t:T) => Type<S>): Type<S> { return kliesli(f)(x) } The kliesli function from bind Going the other way we can define the kliesli function in terms of bind . function kliesli(f:(a:A) => Type<B>): (ma: Type<A> => Type<B>) { return function(ma: Type<A>): Type<B> { return bind(ma, f) } } The mu function from bind function mu(x: Type<Type<A>): Type<A> { const identity: Type<A> => Type<A> = (x) => x` return bind(x, identity) } Kliesli in n-dimensions and liftA2 A function f: (a:A, b:B) => Type<C> can be extended to a function fprime: (ta: Type<A>, tb: Type<B>) => Type<C> . The equation for fprime(ta, tb) is function fprime(ta:Type<A>, tb: Type<B>): Type<C> { bind(ta, (a) => bind(tb, (b) => f(a,b))) } The relationship between f and fprime defines a function I call kliesliA2 where fprime = kliesliA2(f) . This clearly generalizes to function of n-variables of the form f: (a1: A1, a2: A2, ..... an: An) => Type<C> which can be extended to a function fprime:(ta1: Type<A1>, ta2: Type<A2>, ....., tan: Type<An>) => Type<C> . In this n-ary case fprime = kliesliAn(f) Monads lift n-ary operations to n-ary operation Given an n-ary operation op: (a1: A1, a2: A2, ..... an: An) => B apply kliesliAn to the function eta(B) . op: (a1: A1, a2: A2, ..... an: An) => Type<B> KliesliA2 is related to the Haskel function liftA2 . Applying kliesliA2 to the function (recall [A, B] is a tuple) function(a:A, b:B): [Type<[A,B]>] {return eta([a, b])} yields a function of type [Type<A>, Type<B>] => Type<[A, B]> Consider the function f:(a: A, f:(a:A) => B): Type<B> {return eta(f(a))} . This can be lifted by kliesliA2 to a function kliesli2(f): (ta: Type<A>, tf: Type<(a:A) => B>): T<B> which through currying is equivalent to a function (tf: Type<(a:A) => B>) => (Type<A> => Type<B>) . This is the Haskel function <*> . The way types are written in TS makes the above somewhat difficult to express and obscures what is going on. In CT language: Any function f: A x B -> Type<C> lifts to a function `kliesli2 : Type x Type -> Type Applying the previous sentence to the function eta(AxB): A x B -> Type<A x B> yields a function Type<A> x Type<B> -> Type<AxB> . And applying the same logic to the function evaluate: ((A => B) x A) -> B which takes (f: A=>B, a:A) to f(a) yields a function Type<(A => B)> -> (Type<A> => Type<B>). Agaiin this the Haskel function <*>`.","title":"Monad"},{"location":"monad/#monad","text":"A monad is: - a type constructor we will call M , that is a generic type with a single argument, - together with a set of functions (that is free functions or static methods of a class). They are: fmap(f:(a: A) => B): (ma: M<A>) => M<B> eta(a: A): M<A> often called pure or return mu(mma: M<M<A>>): M<A>) kliesli((f:(a: A) => M<B>): (ma: M<A>) => M<B> bind(ma: M<A>, f:(a: A) -> M<B>): M<B> kliesliA2: (f:(a:A, b:B) => M<C>): (ma:M<A>, mb: M<B>) => M<C> app(f:(a:A) => B, ma: M<A>): M<B> Note not all of these functions are independent, that is some can be derived from the others. Generally in this project we will require fmap , eta and either `bind or mu to be provided for each instance of a monad and the others will be derived from those.","title":"Monad"},{"location":"monad/#a-more-formal-definition-of-a-monad","text":"A Monad is a triple (F, eta, mu) or (F, eta, bind) where: F is a functor each type A eta is a function eta(A): (a:A) => F<A> each type A mu is a function mu(A): (x:F<F<A>>) => F<A> each A bind is a function `bind(A,B): (x: F , f: (a:A) => F ) => F Notice the each of eta , mu and bind is actually a family of functions, one for each A . Sometimes in a formula we need to identify which instance of eta or mu we are talking about. The convention in CT is to provide that information as a subscript. But thats difficult to do in markdown inside of a code block. Hence, in discussions, we will pretend eta and mu are function so eta(A) : A => F<A> . The functions eta and mu must satisfy the rules: eta and mu are natural in A . I might discuss later. mu(A) . F.fmap(eta) = identity of A mu(A) . mu(F<A>) = mu(A) . fmap(mu(A)) the equiavelnt conditions on eta and bind are: eta and bind are natural in A and B . I might discuss later. bind(A)(x: F<A>, eta(A): A => F<A>) == x bind(eta(A)(a), f: A => F<B>) == f(a) bind(bind(ma, f), g) == bind(ma, ((x) => bind(f(x), g))) where g: B => F C and f: A => F B","title":"A more formal definition of a Monad"},{"location":"monad/#start-with-the-core-monad-elements","text":"Lets now assume we have a monad defined as a TS module. The details of the generic type Type<T> and the functions fmap , eta , and mu are left unspecified as we do not wish to use the specific details of any particular monad. type Type<T> = ... const fmap<A, B>: (f:(a: A) => B): (ma: Type<A>) => Type<B> = ... const eta<A> : (a:A) => Type<A> = .... const mu<A> :(a:Type<Type<A>>) => Type<A> = .... Now we will construct some other well known Monad functions from those beginnings.","title":"Start with the core monad elements"},{"location":"monad/#kliesli-function","text":"The universal property of a Monad M is that forever f: A => M.Type<B> there is a unique g: M.Type<A> => M<B> sucn that g . eta(A) = f . In fact g = mu(M.Type<A>) . M.fmap(f) I like to think of the function g as the Kliesli lifting of f and to write it as kliesli(f) . The following code is inside the module representing M . Note I have elaborate with the steps and the typing to ensure understanding of what is happening. function kliesli<A,B>(f:(a: A) => Type<B>): (ma: Type<A>) => Type<B> { const r1 = fmap(f) return function(x:Type<A>): Type<B> { const fmap_f: (x: Type<A>) => Type<Type<B>> = fmap(f) const z1: Type<Type<B>> = fmap_f(x) const z2: Type<B> = mu(z1) return z2 } }","title":"Kliesli Function"},{"location":"monad/#the-bind-function-in-terms-of-the-kliesli-function","text":"Haskel defines the bind function as an infix operation named >>= . TS does not permit custom infix operations so we have to be content with function of two arguments. To provide motivation const ma: Type<A> const f: (a:A) => Type<B> const mb: Type<B> = (ma >>= f) is the same as kliesli(f)(ms) More formally function bind<T,S>(x: Type<T>, f: (t:T) => Type<S>): Type<S> { return kliesli(f)(x) }","title":"The bind function in terms of the kliesli function"},{"location":"monad/#the-kliesli-function-from-bind","text":"Going the other way we can define the kliesli function in terms of bind . function kliesli(f:(a:A) => Type<B>): (ma: Type<A> => Type<B>) { return function(ma: Type<A>): Type<B> { return bind(ma, f) } }","title":"The kliesli function from bind"},{"location":"monad/#the-mu-function-from-bind","text":"function mu(x: Type<Type<A>): Type<A> { const identity: Type<A> => Type<A> = (x) => x` return bind(x, identity) }","title":"The mu function from bind"},{"location":"monad/#kliesli-in-n-dimensions-and-lifta2","text":"A function f: (a:A, b:B) => Type<C> can be extended to a function fprime: (ta: Type<A>, tb: Type<B>) => Type<C> . The equation for fprime(ta, tb) is function fprime(ta:Type<A>, tb: Type<B>): Type<C> { bind(ta, (a) => bind(tb, (b) => f(a,b))) } The relationship between f and fprime defines a function I call kliesliA2 where fprime = kliesliA2(f) . This clearly generalizes to function of n-variables of the form f: (a1: A1, a2: A2, ..... an: An) => Type<C> which can be extended to a function fprime:(ta1: Type<A1>, ta2: Type<A2>, ....., tan: Type<An>) => Type<C> . In this n-ary case fprime = kliesliAn(f)","title":"Kliesli in n-dimensions and liftA2"},{"location":"monad/#monads-lift-n-ary-operations-to-n-ary-operation","text":"Given an n-ary operation op: (a1: A1, a2: A2, ..... an: An) => B apply kliesliAn to the function eta(B) . op: (a1: A1, a2: A2, ..... an: An) => Type<B>","title":"Monads lift n-ary operations to n-ary operation"},{"location":"monad/#klieslia2-is-related-to-the-haskel-function-lifta2","text":"Applying kliesliA2 to the function (recall [A, B] is a tuple) function(a:A, b:B): [Type<[A,B]>] {return eta([a, b])} yields a function of type [Type<A>, Type<B>] => Type<[A, B]> Consider the function f:(a: A, f:(a:A) => B): Type<B> {return eta(f(a))} . This can be lifted by kliesliA2 to a function kliesli2(f): (ta: Type<A>, tf: Type<(a:A) => B>): T<B> which through currying is equivalent to a function (tf: Type<(a:A) => B>) => (Type<A> => Type<B>) . This is the Haskel function <*> . The way types are written in TS makes the above somewhat difficult to express and obscures what is going on. In CT language: Any function f: A x B -> Type<C> lifts to a function `kliesli2 : Type x Type -> Type Applying the previous sentence to the function eta(AxB): A x B -> Type<A x B> yields a function Type<A> x Type<B> -> Type<AxB> . And applying the same logic to the function evaluate: ((A => B) x A) -> B which takes (f: A=>B, a:A) to f(a) yields a function Type<(A => B)> -> (Type<A> => Type<B>). Agaiin this the Haskel function <*>`.","title":"KliesliA2 is related to the Haskel function liftA2."}]}